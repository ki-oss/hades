{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> HADES (HADES Asynchronous Discrete-Event Simulation) is a small, user friendly framework for creating simulations in python! </p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udfb2\ud83e\udd16 Supports both Agent Based and Process Based models - how you model the entities in your simulation is up to you!</li> <li>\u26a1 Async execution within a time-step - designed for working IO-bound workloads over the network (e.g. LLM APIs, db lookups, etc)</li> <li>\ud83d\udcc8 Visualisation - <code>websockets</code> support to for building a custom frontend for your sim, <code>matplotlib</code> in a Jupyter notepad or simply outputting a <code>mermaid</code> diagram</li> <li>\ud83c\udff7\ufe0f Pydantic style immutable events - type hints and enforcement make sure its clear what events contain</li> <li>\ud83d\udce6 Encapsulated simulated processes - processes or agents are encapsulated, keeping state manageable and making it possible to swap processes in and out</li> <li>\ud83d\ude0a User friendly - pattern matching on pydantic based events makes for an intuitive way to build simulations, while the separation of state helps avoid potential footguns!</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hades-framework\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Using the Hades Framework is as simple as creating your custom <code>Process</code>es and <code>Event</code>s, registering them in the simulation, and letting Hades take care of the rest.</p>"},{"location":"#examples","title":"Examples","text":"<p>Here are some of the fun things you might do with it:</p> <ul> <li>Simple Simulation - A simple simulation of Odysseus dodging the wrath of the gods to get started with</li> <li>Boids and Websockets - The classic Boids simulation with live canvas and d3.js visualisation via websockets.     </li> <li>Multi Agent LLM Storytelling -  Retelling the Odyssey with LLMs - demonstrates the highly IO bound stuff hades is good at. Some output:     &gt;   \"He remembered the sea nymph who had helped him before and realized that having allies like her was crucial to his success.          He also continued to use his technological knowledge to stay ahead of Poseidon's wrath, utilizing his drone and sonar to navigate the waters safely.\"</li> <li>Battery charging station - to help compare what building a simulation looks with <code>simpy</code> vs <code>hades</code></li> </ul>"},{"location":"core/","title":"Core","text":""},{"location":"core/#event","title":"Event","text":""},{"location":"core/#process","title":"Process","text":""},{"location":"core/#hades.core.process","title":"<code>hades.core.process</code>","text":"<p>The entity doing the main body of work within the simulation is the <code>Process</code>. The <code>notify(event)</code> method of every process registered  (via <code>hades_instance.register_process()</code>) will be called for each event in the queue for the next time step as a group of asynchronous tasks. That is to say: events are broadcast and handled asynchronously by the registered processes.  For justification of this see the design justification.</p>"},{"location":"core/#hades.core.process--pattern-matching-events","title":"Pattern matching events","text":"<p>The pattern suggested for processes, is for the process to <code>match</code> events that it uses and respond with some sort of acknowledgement of what was done with the event. E.g.</p> <pre><code>from hades import NotificationResponse, Hades, Event\n\nclass MyProcess(Process):\n    def __init__(self, important_identifiers: list[str]):\n        self._important_identifiers = important_identifiers\n\n    async def notify(self event: Event):\n        match event:\n            case SomeEvent(t=t, some_identifier=some_identifier, data=data):\n                if some_identifier not in important_identifiers:\n                    return NotificationResponse.ACK_BUT_IGNORED\n                data_for_other_event = self._do_something_with_data(d)\n                self.add_event(OtherEvent(t=t+1, data=data_for_other_event))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"core/#hades.core.process--process-notifications-and-asynchronous-handling","title":"Process Notifications and Asynchronous Handling","text":"<p>The Hades Framework's core functionality involves handling and broadcasting events asynchronously.  The implementation uses Python's native asyncio library for task scheduling and execution.  All events for a given time-step are broadcast to all registered processes and handled independently within their context.</p>"},{"location":"core/#hades.core.process--asynchronous-behaviour-and-data-consistency","title":"Asynchronous Behaviour and Data Consistency","text":"<p>However, as powerful as this design pattern may be, it also introduces a certain level of complexity when dealing with shared data resources.</p> <p>Consider the scenario where multiple events are sent to a single process, and each event triggers modifications on a shared data resource, for example, a list within the process. Since all the events are handled asynchronously and independently, the order of execution is not guaranteed, and data inconsistency can arise due to race conditions.</p> <p>This is a critical aspect of using the Hades Framework: always ensure data consistency and thread-safety when designing your processes.</p>"},{"location":"core/#hades.core.process--managing-asynchronous-operations-within-processes","title":"Managing Asynchronous Operations within Processes","text":"<p>Here are some recommended ways to handle shared data within processes:</p> <ul> <li>Use synchronization primitives: Python's asyncio library provides several synchronization primitives like locks (asyncio.Lock()) and semaphores (asyncio.Semaphore()).  Use these primitives to ensure only one coroutine within a process modifies the shared resource at any given time.</li> <li>Immutable data structures: If possible, use immutable data structures. This eliminates the possibility of shared data being modified concurrently by different coroutines, thus avoiding race conditions.</li> <li>Avoid shared state: Whenever possible, avoid using shared state within processes. Design your processes such that they work primarily with local data (from the event).</li> </ul> <p>Note</p> <p>There is no need to worry about this between processes (as they shouldn't share mutable state), only multiple events handled within the same process.</p> <p>Example of this: <pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport asyncio\n\nfrom hades import Event, Hades, NotificationResponse, Process\n\n\nclass EventOne(Event):\n    pass\n\n\nclass EventTwo(Event):\n    pass\n\n\nclass MyProcess(Process):\n    def __init__(self):\n        super().__init__()\n        self._event_data_list = []\n\n    async def notify(self, event: Event):\n        match event:\n            case EventOne(t=t):\n                print(\"event one arrives first\")\n                await asyncio.sleep(0.1)  # Simulate a delay\n                self._event_data_list.append(\"One\")\n                return NotificationResponse.ACK\n            case EventTwo(t=t):\n                print(\"event two arrives second\")\n                await asyncio.sleep(0.05)\n                self._event_data_list.append(\"Two\")\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n\n\nclass MyLockingProcess(MyProcess):\n    def __init__(self):\n        super().__init__()\n        self.lock = asyncio.Lock()\n\n    async def notify(self, event: Event):\n        async with self.lock:\n            return await super().notify(event)\n\n\nasync def test_async_notify(capsys):\n    hades = Hades()\n\n    process = MyProcess()\n\n    hades.register_process(process)\n\n    # note these arrive at the same timestep\n    hades.add_event(process, EventOne(t=0))\n    hades.add_event(process, EventTwo(t=0))\n\n    await hades.run()\n\n    # two happens before one\n    assert process._event_data_list == [\"Two\", \"One\"]\n    # even though one arrives before two\n    assert capsys.readouterr().out == \"\"\"event one arrives first\nevent two arrives second\n\"\"\"\n\n\nasync def test_async_notify_with_lock(capsys):\n    hades = Hades()\n\n    process = MyLockingProcess()\n\n    hades.register_process(process)\n\n    hades.add_event(process, EventOne(t=0))\n    hades.add_event(process, EventTwo(t=0))\n\n    await hades.run()\n\n    # with the lock events happen in the order they arrive.\n    assert process._event_data_list == [\"One\", \"Two\"]\n    assert capsys.readouterr().out == \"\"\"event one arrives first\nevent two arrives second\n\"\"\"\n</code></pre></p>"},{"location":"core/#hades.core.process.PredefinedEventAdder","title":"<code>PredefinedEventAdder</code>","text":"<p>             Bases: <code>Process</code></p> <p>adds some predefined events to hades then unregisters itself to avoid any overhead</p> Source code in <code>hades/core/process.py</code> <pre><code>class PredefinedEventAdder(Process):\n    \"\"\"adds some predefined events to hades then unregisters itself to avoid any overhead\"\"\"\n\n    def __init__(self, predefined_events: list[Event], name: str) -&gt; None:\n        super().__init__()\n        self._name = name\n        self._events = predefined_events\n\n    @property\n    def instance_identifier(self):\n        return self._name\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case SimulationStarted(t=t):\n                for event in self._events:\n                    self.add_event(event)\n                self.add_event(ProcessUnregistered(t=t))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"core/#hades.core.process.Process","title":"<code>Process</code>","text":"Source code in <code>hades/core/process.py</code> <pre><code>class Process:\n    def __init__(self) -&gt; None:\n        self.add_event_to_hades: None | AddEventCallback = None\n        self._random_process_identifier: int = -1\n        self._str: str | None = None\n\n    @property\n    def process_name(self):\n        return self.__class__.__name__\n\n    @property\n    def instance_identifier(self) -&gt; str:\n        \"\"\"\n        unique identifier for the process. This does not need to be globally unique however, multiple instances of a given process_name\n        with the same instance identifier will not be allowed across the styx (into hades)\n        \"\"\"\n        return str(self._random_process_identifier)\n\n    def __str__(self) -&gt; str:\n        if self._random_process_identifier != -1:\n            return f\"process: {self.process_name}, instance: {self.instance_identifier}\"\n        if self._str is None:\n            self._str = f\"process: {self.process_name}, instance: {self.instance_identifier}\"\n        return self._str\n\n    def add_event(self, event: Event):\n        if self.add_event_to_hades is None:\n            raise ValueError(\n                f\"add event to hades callback must be set before {self.process_name} can add events to the world\"\n            )\n        self.add_event_to_hades(self, event)\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        raise NotImplementedError(f\"notify must be implemented for {self.process_name} processes\")\n</code></pre>"},{"location":"core/#hades.core.process.Process.instance_identifier","title":"<code>instance_identifier: str</code>  <code>property</code>","text":"<p>unique identifier for the process. This does not need to be globally unique however, multiple instances of a given process_name with the same instance identifier will not be allowed across the styx (into hades)</p>"},{"location":"core/#hades.core.process.RandomProcess","title":"<code>RandomProcess</code>","text":"<p>             Bases: <code>Process</code></p> <p>a process which adds a .random attribute with the given seed</p> Source code in <code>hades/core/process.py</code> <pre><code>class RandomProcess(Process):\n    \"\"\"a process which adds a .random attribute with the given seed\"\"\"\n\n    def __init__(self, seed: str | None) -&gt; None:\n        super().__init__()\n        self.random = random.Random(seed or self._random_process_identifier)\n\n    def _generate_uuid(self, version: int = 4) -&gt; uuid.UUID:\n        \"\"\"generate a uuid using the random seed\"\"\"\n        return uuid.UUID(int=self.random.getrandbits(128), version=version)\n</code></pre>"},{"location":"design-justification/","title":"HADES - Design Justification","text":""},{"location":"design-justification/#original-goal-and-problem","title":"Original Goal and Problem","text":"<p>The goal from which HADES originates is that of creating a framework which makes it easy to simulate how an insurance company's portfolio would  change over time given different scenarios. As these scenarios get more complex, problems begin to emerge:</p> <ol> <li>It becomes difficult to track state in a manageable way - e.g. needing to track which policies we have written and claims incurred in a simulated book to impact future portfolio management</li> <li>We begin coming across situations where we need to do simulation E.g. If one thing changes in the past, we can't ignore its effect on things which come after it. </li> </ol>"},{"location":"design-justification/#requirements","title":"Requirements","text":"<p>Given this goal, the requirements in more depth are as follows:</p> <ol> <li> <p>Functional requirements:</p> <ol> <li>It needs to simplify handling things which change over time</li> <li>It needs to have a convenient way of handling state - e.g. the state of policies should only be tracked by elements which care about policies</li> <li>It needs to be be easy to combine sources of data - e.g. combining real with generated quotes, historic broker behaviour with simulated behaviour, historic catastrophes with hypothetical ones</li> </ol> </li> <li> <p>Technical requirements - coming from the perspective of interacting with our existing software:</p> <ol> <li>It should be able to interact with distributed systems - e.g. calling services over the network which may or may not be running on the same physical or virtual machine</li> <li>It should reasonably fast (to enable its use in certain optimization approaches) - e.g. within the constraints of things having to happen in order, it should be as speedy as is relatively easily achievable</li> <li>It should be python based</li> </ol> </li> <li> <p>User experience requirements - coming from a 'designing software for humans' point of view:</p> <ol> <li>It should be as easy to understand and use as possible for users with limited software development experience</li> <li>It should be plug-in and play: users shouldn't need to understand the entirety of a simulation to alter or replace a component of it</li> <li>State should be encapsulated and it should be obvious where it should be.</li> </ol> </li> </ol>"},{"location":"design-justification/#evaluation-of-candidate-solutions","title":"Evaluation Of Candidate Solutions","text":"<p>Given these functional requirements, research was done on typical solutions to these kinds of problems. A full list of resources is provided at the bottom.</p> <p>The main conclusions I came to from this are:</p>"},{"location":"design-justification/#kinds-of-simulations","title":"Kinds Of Simulations","text":"<p>Considering various simulation approaches, a DES approach seemed to best fit the problem.</p> <p>Agent-Based models,approaches also seemed pretty applicable for some aspects, however when diving deeper into their handling of time and how they actually work as a simulation they seemed to either work similarly to DES approaches<sup>1</sup>, potentially making some alterations to where the <code>step()</code> occurs<sup>2</sup>. </p> <p>The difference typically comes down to emphasis on 'emergent behaviour' and large numbers of instances of certain entities. On the analysis side this tends to lead to visualisations focusing on dynamics/interactions between agents as opposed to states of particular objects.</p> <p>Often DES can be used interchangeably with process based simulations, however here we use the broader meaning, leaving the model to userland.</p> <p>That is to say with the a DES core, Hades can be used for either agent based or process based models<sup>14</sup>.</p> <p>Other simulation approaches e.g. System Dynamics (too abstract to give concrete specific outputs) or Continuous (too difficult to build any reasonably complex and detailed model with) approaches seem to not be applicable. </p>"},{"location":"design-justification/#time-progression-should-be-next-event-based-satisfying-2b","title":"Time progression should be next-event based - satisfying 2.b","text":"<p>This means that if there are two events scheduled e.g. \\(e_{1_{t_1}}\\) and \\(e_{2_{t_3}}\\) the simulation framework,  after processing \\(e_1\\) at \\(t_1\\) will skip \\(t_2\\) and immediately process \\(e_2\\). </p> <p>From a performance perspective this makes sense. The alternative - incremental time progression involves processing at every time-step, meaning unnecessary work. If this mode is needed events can be generated for each of the time steps anyway and thus is a special, less performant case of next-event based approaches. </p> <p>From a business perspective this makes sense too. Things in insurance typically happen with reasonable gaps between them.</p>"},{"location":"design-justification/#using-existing-frameworks","title":"Using existing frameworks","text":"<p>Given the above, the best existing candidate seemed to be a python library (satisfying 2.c) called Simpy<sup>3</sup>. </p> <p>This library relies on python's <code>yield</code> keyword and generator functions to represent processes. It also has a nice functional design.</p> <p>However upon experimenting with it a little I found a few issues with it regarding the above requirements.</p> <p>From a technical perspective, 2.a would have been a bit difficult to achieve. This is because <code>Environment.process</code>, <code>start_delayed</code> etc are 'sync' coloured and I was considering that the best way to achieve 2.a and 2.b would be to gather events occurring at the same time-step so that they are executed asynchronously, allowing distributed elements to handle the concurrent processing. However this could probably be overcome by either subclassing/extending or using a fork called \u03bcSim<sup>4</sup>. </p> <p>More importantly though, having experimented with it for a while the user experience seemed like it would be suboptimal. </p> <p>Firstly, the <code>yield</code> keyword's behaviour is not always intuitive and anything which adds to cognitive load or makes the framework less accessible to newer to python users subtracts from 3.a. </p> <p>Secondly the way processes need communicate is either by having references to each other. E.g. in order for process <code>a</code> to call process <code>b</code>, we must pass a reference to <code>a</code> e.g. <code>a(b)</code>.  This means that there is an implicit hierarchy built into any design which makes achieving 3.b harder. </p> <p>Thirdly, how to manage state best is a little unclear. Classes in the documentation may include multiple processes<sup>5</sup> (so they can reference one another easier), or share state by mutating some mutable object passed to multiple functional processes by reference<sup>6</sup>. Violating 3.c</p>"},{"location":"design-justification/#taking-notes-from-game-development","title":"Taking notes from Game Development","text":"<p>Games are real-time, dynamic, interactive computer simulations<sup>7</sup>. They are also large pieces of software contributed to by big, distributed teams who, often by necessity, cannot be aware of the full system (satisfying 3.b). It is often scripted by Game Designers who are not necessarily experienced as engineers<sup>8</sup> (satisfying 3.a). Given this, we can probably learn a lot from looking at patterns used in Game Development. </p>"},{"location":"design-justification/#eventlifecycle-functions-arent-the-best-fit","title":"Event/Lifecycle functions aren't the best fit","text":"<p>At the most basic level game engine loops (even more generally rendering loops) are a <code>while</code> loop which will often call some event functions of registered components (hollywood style)<sup>9</sup>. This approach is used by the popular Unity framework<sup>10</sup>. While this makes implementing components very easy, there is essentially a lack of extensibility in terms of adding different types of events since to know when to call them. It is best for systems with a fixed set of events which can occur in a loop like unity's main loop or event more simply - Ogre's<sup>11</sup>.</p>"},{"location":"design-justification/#the-observer-pattern","title":"The Observer Pattern","text":"<p>Looking at other patterns used in Game Development, the classic Observer Pattern<sup>12</sup> gives us some nice things. A small python implementation can be seen in Appendix C The decoupling of subjects from observers makes state management easier, it is natural for subjects to not have a direct reference to a particular observer, stemming to some extent the temptation to share state. Subjects only have to take care of sending out events to their <code>Observers</code>, not who those observers are. The paradigm of having certain events which are passed about also makes for a somewhat extensible situation where events might be shared by different <code>Subjects</code>, and therefore satisfying requirement 3.b.</p> <p>However there are also some less desirable properties. Firstly the decoupling is not complete, observers have to know about their subjects. This inhibits 3.b as components of the system become less interchangeable, and makes 3.c a bit harder to achieve, and since both observers and subjects can 'see' each other, the potential for state not being encapsulated is there.</p> <p>To me, this is the difference between \u201cobserver\u201d systems and \u201cevent\u201d systems. With the former, you observe the thing that did something interesting. With the latter, you observe an object that represents the interesting thing that happened. -- Game Programming Patterns <sup>12</sup></p> <p>A further difficulty is that observer pattern notifications typically happen instantly. There is no intermediary scheduling the events for a later point in time. </p> <p>Additionally sometimes a modelled entity would make most intuitive sense as being both a subject and an observer. </p>"},{"location":"design-justification/#event-queues","title":"Event Queues","text":"<p>A queue stores a series of notifications or requests in first-in, first-out order. Sending a notification enqueues the request and returns. The request processor then processes items from the queue at a later time. Requests can be handled directly or routed to interested parties. This decouples the sender from the receiver both statically and in time. -- Game Programming Patterns <sup>13</sup></p> <p>As can be seen from the above, the event queue pattern essentially fixes all of our issues with the observer pattern! Woo hoo! We will have observer like objects being notified of events and modifying their state based on them.</p> <p>However we need to make some modifications and design decisions before all our requirements are met.</p>"},{"location":"design-justification/#design-decisions","title":"Design Decisions","text":"<p>Now we've settled on the pattern for the framework we need to make a few design decisions</p>"},{"location":"design-justification/#use-a-priority-queue","title":"Use a Priority Queue","text":"<p>Unlike the event queue described above, First-In-First-Out is not what we want for a DES where events may be scheduled far before their occurrence or perhaps even at the same time step as it! What we want instead is a priority queue so that the events which will happen the soonest are at the front of it.</p>"},{"location":"design-justification/#static-events-not-messages-or-dynamic-events","title":"Static Events, not Messages or Dynamic Events","text":"<p>So now we have a queue, what sort of things should we put on it? Dynamic events would be some sort of function which is queued and then executed (potentially altering some state) at a future time. This approach seems really tricky to trace and loses quite a lot of the nice properties regarding how plug-and-play things are. So let's rule this out.</p> <p>Static events and messages are quite similar, but messages are typically terser and more like commands intended to be used in a specific way rather than data rich events upon which receives can act as they please. Therefore static events seemed to make the most sense.</p>"},{"location":"design-justification/#broadcast-events","title":"Broadcast Events","text":"<p>Clearly in any reasonably complex simulation, events are going to need to be listened to by a few different processes. A single cast queue would not therefore make sense.</p> <p>Similarly a work-queue doesn't make sense, multiple processes may well be interested in the same events.</p> <p>Potentially processes could subscribe only to certain types of events but this would add complexity for very marginal computational gain compared to broadcast and ignore. It could also lead to patterns where certain processes only don't consume certain events because they are not subscribed to it making interoperability (will process p work in sim S) and parametrisation (which events it is subscribed to in some test) entangled. </p>"},{"location":"design-justification/#multiple-writer","title":"Multiple Writer","text":"<p>All processes can write events to the queue. This is in line with the plug-and-play aim of 3.b.</p>"},{"location":"design-justification/#event-grouping-and-async","title":"Event Grouping and Async","text":"<p>Since we have the 2.a and 2.b requirements, we broadcast all the events for the next time-step with events out to all the processes asynchronously. This means that we process as much as we can concurrently (where the implementation of the event notification receiving code allows). CPU-bound tasks can be offloaded to external systems this way too.</p>"},{"location":"design-justification/#events-on-the-same-time-step","title":"Events On The Same Time Step.","text":"<p>Small consideration, but we have the option here of only allowing future events or allowing events on the same time step too. Although the future one seems cleaner at first glance, it does mean that a lot of patterns involving 'timeless' process communication are prevented which seems like a sacrifice not worth making.</p>"},{"location":"design-justification/#caveats","title":"Caveats","text":"<p>Obviously there are no free lunches and the framework as it is has some shortcomings</p>"},{"location":"design-justification/#state-is-not-shared","title":"State Is Not Shared","text":"<p>While I have been describing this as a feature, it also makes certain things harder and can lead to somewhat duplicate state in some cases. There are certain ways around this e.g. taking a leaf from Simpy's book and at process <code>__init__</code> time passing in some mutable data structure to multiple processes. However this is at-the-user's own peril and not forced or encouraged by the framework. However for immutable objects this is encouraged.</p>"},{"location":"design-justification/#loops-can-occur","title":"Loops Can Occur","text":"<p>With processes reading and writing to the queue it is possible for feedback loops to occur ad infinitum. Sometimes this can be desirable and represent an existing feedback system, however in others, especially combined with the fact that same time step events are allowed, this could lead to undesired loops if not careful. </p> <p>Suggestion here is just to be careful and that debug level logs can help! </p>"},{"location":"design-justification/#everything-is-public","title":"Everything is public","text":"<p>Since all events are broadcast, there is, by default, no private communication, and processes have to enforce this by passing events with identifiers to indicate origin where necessary.</p>"},{"location":"design-justification/#its-not-very-battle-tested","title":"Its not very 'battle-tested'","text":"<p>As a new framework, its not particularly battle tested and there may be more caveats to be uncovered! </p>"},{"location":"design-justification/#further-reading","title":"Further Reading","text":"<p>Some stuff not referenced in the footnotes which was interesting.</p> <ul> <li>https://www.jasss.org/18/3/9.html - paper comparing sim design approaches</li> <li>https://a-b-street.github.io/docs/tech/trafficsim/discrete_event/index.html</li> <li>https://heather.cs.ucdavis.edu/~matloff/SimCourse/PLN/SimIntro.pdf</li> <li>https://www.brianstorti.com/the-actor-model/</li> <li>https://www.youtube.com/watch?v=eZfj7LEFT98</li> <li>https://www.didierboelens.com/2019/01/futures-isolates-event-loop/</li> <li>https://users.cs.northwestern.edu/~agupta/_projects/networking/QueueSimulation/mm1.html</li> </ul>"},{"location":"design-justification/#footnotes","title":"Footnotes","text":"<ol> <li> <p>The classic MASON framework)\u00a0\u21a9</p> </li> <li> <p>Python's MESA framework \u21a9</p> </li> <li> <p>Simpy documentation. The tutorial is pretty good and instructive \u21a9</p> </li> <li> <p>\u03bcSim documentation \u21a9</p> </li> <li> <p>Simpy machine shop example \u21a9</p> </li> <li> <p>Simpy movie renege example \u21a9</p> </li> <li> <p>Great book on architecture of game engines \u21a9</p> </li> <li> <p>This distinction between scripting vs programming / Designer vs Engineer split is explained clearly in this Quora answer \u21a9</p> </li> <li> <p>Inversion of Control/Hollywood Principle \u21a9</p> </li> <li> <p>Nice diagram of Unity Execution of Events ordering \u21a9</p> </li> <li> <p>Ogre's main render loop \u21a9</p> </li> <li> <p>Excellent article on the Observer Pattern in game programming \u21a9\u21a9</p> </li> <li> <p>Excellent article on Event Queues in game programming \u21a9</p> </li> <li> <p>Any Logic Whitepaper \u21a9</p> </li> </ol>"},{"location":"api_reference/event/","title":"Event","text":"<p><code>Event</code>s in <code>Hades</code> are immutable <code>pydantic</code> models including some <code>t</code> value - the time-step in the simulation when the event occurs, and data or identifiers relating to the event.</p> <p>Events in <code>Hades</code> are static meaning that they are do not contain logic relating to the event as with some other DES frameworks. See design justification for why!</p> <p>Events should use a consistent tense. Here past is used</p> <p>It will often be the case that events will need to contain identifying information for processes to identify which entity it relates  to within their internal state. In addition it will often be necessary to pass around data.</p> <p>Another thing which may be useful is some kind of audience identifier, which can help processes distinguish quickly whether to  do anything with a give event.</p> <p>Suggested way to structure this is as follows:</p> <p>Suppose we have two Event kinds relating to frogs:</p> <ul> <li><code>FrogSpawned</code></li> <li><code>FrogTransformed</code></li> </ul> <pre><code>class FrogLifeCycleStage(Enum):\n    SPAWN = 1\n    TADPOLE = 2\n    FROGLET = 3\n    FROG = 4\n\nclass FrogSpawned(Event):\n    frog_id: str\n    audience_pond_id: str\n\n    initial_stage: FrogLifeCycleStage\n    frog_genetic_data: GeneticData\n\nclass FrogTransformed(Event):\n    frog_id: str\n    # we dont need the audience here because we might well assume that a frog will spend its whole life in the start pond\n    # we also dont need the genetic data because \n    transformed_to: FrogLifeCycleStage\n</code></pre> <p>This ensures that processes can cleanly identify whether the event relates to an entity they are interested in and makes a distinction between data (which may be quite sizeable) isn't being unnecessarily passed around.</p>"},{"location":"api_reference/event/#hades.core.event.Event","title":"<code>Event</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>base event - event occurrence step t must be included. It is immutable and hashable</p> Source code in <code>hades/core/event.py</code> <pre><code>class Event(BaseModel):\n    \"\"\"base event - event occurrence step t must be included. It is immutable and hashable\"\"\"\n\n    t: int\n\n    @property\n    def name(self):\n        return self.__class__.__name__\n\n    model_config = ConfigDict(frozen=True)\n</code></pre>"},{"location":"api_reference/event/#hades.core.event.ProcessUnregistered","title":"<code>ProcessUnregistered</code>","text":"<p>             Bases: <code>Event</code></p> <p>special event for unregistered the process who sent this event. it is unique in that it will be consumed by hades and not broadcast to other processes.</p> Source code in <code>hades/core/event.py</code> <pre><code>class ProcessUnregistered(Event):\n    \"\"\"\n    special event for unregistered the process who sent this event.\n    it is unique in that it will be consumed by hades and not broadcast to other processes.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/event/#hades.core.event.SimulationEnded","title":"<code>SimulationEnded</code>","text":"<p>             Bases: <code>Event</code></p> <p>Signals the simulation has ended.</p> Source code in <code>hades/core/event.py</code> <pre><code>class SimulationEnded(Event):\n    \"\"\"Signals the simulation has ended.\"\"\"\n</code></pre>"},{"location":"api_reference/event/#hades.core.event.SimulationStarted","title":"<code>SimulationStarted</code>","text":"<p>             Bases: <code>Event</code></p> <p>special event issued by hades to kick off the sim</p> Source code in <code>hades/core/event.py</code> <pre><code>class SimulationStarted(Event):\n    \"\"\"special event issued by hades to kick off the sim\"\"\"\n\n    t: int = 0\n</code></pre>"},{"location":"api_reference/hades/","title":"Hades","text":""},{"location":"api_reference/hades/#event-loop","title":"Event Loop","text":"<p>The most important part of Hades is its core event loop.</p> <p>Here is how it works.</p> <pre><code>graph TB\n    G[Getting Events for Next Timestep]\n    I[Broadcast Events asynchronously to all registered Processes]\n    K[Take top event from t Priority Queue]\n    L[Move self.t to event.t]\n    M[Collect all events at time self.t from priority queue]\n    Z[End Simulation]\n    N[Processes maybe add more events to the priority queue]\n    O[Handle event results]\n\n\n    G --&gt; K\n    K --&gt; | event.t &gt; \u00a0current simulation time | L\n    L --&gt; M\n    K --&gt; | event.t == \u00a0current simulation time | M\n    K --&gt; | no event on queue | Z\n    M --&gt; | self.t &gt; specified run until time | Z\n    M --&gt; I\n    I --&gt; N\n    N --&gt; O\n    O --&gt; G</code></pre> <p>Important</p> <p>Events can never be added in the past but they can be added for the current timestep</p>"},{"location":"api_reference/hades/#module","title":"Module","text":"<p><code>Hades</code> the core simulation class, responsible for registering <code>processes</code>, managing the <code>event</code> priority queue, and distributing messages to  the <code>processes</code>.</p>"},{"location":"api_reference/hades/#hades.core.hades.Hades","title":"<code>Hades</code>","text":"Source code in <code>hades/core/hades.py</code> <pre><code>class Hades:\n    def __init__(\n        self,\n        random_pomegranate_seed: str | None = \"hades\",\n        max_queue_size: int = 0,\n        batch_event_notification_timeout: int | None = 60 * 5,\n        record_results: bool = True,\n        record_event_history: bool = True,\n        use_no_ack_cache: bool = False,\n        track_causing_events: bool = False,\n    ) -&gt; None:\n        \"\"\"Hades initialisation, specify core simulation parameters and performance optimisations\n\n        Args:\n            random_pomegranate_seed (str | None, optional): a random seed, used to initialise process instance identifiers etc. Defaults to \"hades\".\n            max_queue_size (int, optional): how large the event queue is allowed to grow to, infinite by default. Defaults to 0.\n            batch_event_notification_timeout (int | None, optional): how long to wait for a batch of events (at a timestep) before erroring. Defaults to 60*5.\n            record_results (bool, optional): performance measure - whether to record process responses to events in self._event_results. Defaults to True.\n            record_event_history (bool, optional): performance measure - whether to record event history in self.event_history. Defaults to True.\n            use_no_ack_cache (bool, optional): performance measure - whether to stop notifying target processes of event types once they respond with a NO_ACK to one. Defaults to False.\n            track_causing_events (bool, optional): performance measure - whether to track which events caused other events, may be useful for downstream visualisation but not required functionally. Defaults to False.\n        \"\"\"\n        self.random = random.Random(random_pomegranate_seed)\n        self.event_queue: PriorityQueue = PriorityQueue(maxsize=max_queue_size)\n        self.t = 0\n        self._processes: list[Process] = []\n        self._batch_event_notification_timeout = batch_event_notification_timeout\n        self.event_history: list[tuple[tuple[Event, Process, Event | None], ...]] = []\n        self.event_results: dict[tuple[Event, str, str, Event | None], dict[tuple[str, str], NotificationResponse]] = {}\n\n        self._event_count = count()\n        self._record_results = record_results\n        self._record_event_history = record_event_history\n        self._use_no_ack_cache = use_no_ack_cache\n        self._track_causing_event = track_causing_events\n        self._no_ack_cache: set[tuple[str, str]] = set()\n\n    def add_event(self, process: Process, event: Event):\n        if self.t &gt; event.t:\n            raise ValueError(f\"cannot create events in the past {event=} from {process=}\")\n        causing_event = None\n        # look up the event which caused this event to exist\n        if self._track_causing_event:\n            current_frame = inspect.currentframe()\n            if not current_frame or not current_frame.f_back or not current_frame.f_back.f_back:\n                raise ValueError(\"could not causing event\")\n\n            caller_frame = current_frame.f_back.f_back\n            caller_arguments = inspect.getargvalues(caller_frame)\n            if not isinstance(caller_arguments, inspect.ArgInfo):\n                raise TypeError(f\"bad caller arguments {caller_arguments}\")\n            if caller_arguments.locals[\"self\"] is process:\n                causing_event = caller_arguments.locals.get(\"event\")\n\n        queue_event = (event.t, next(self._event_count), (event, process, causing_event))\n        _logger.debug(\"adding %s from %s (caused by %s) to queue\", event.name, process, causing_event)\n        self.event_queue.put(queue_event)\n\n    def register_process(self, process: Process):\n        if process.instance_identifier == \"-1\":\n            process._random_process_identifier = self.random.getrandbits(128)\n\n        for existing_process in self._processes:\n            if (\n                existing_process.instance_identifier == process.instance_identifier\n                and existing_process.process_name == process.process_name\n            ):\n                raise ValueError(\n                    f\"process {process.process_name}: {process.instance_identifier} already exists within the\"\n                    \" environment, cannot add twice\"\n                )\n\n        process.add_event_to_hades = self.add_event\n\n        self._processes.append(process)\n        _logger.info(f\"registered %s\", process)\n\n    def unregister_process(self, process: Process):\n        _logger.info(\"unregistered %s\", process)\n        self._processes = [\n            existing_process for existing_process in self._processes if id(existing_process) != id(process)\n        ]\n\n    def _get_events_for_next_timestep(self) -&gt; list[QueuedEvent]:\n        \"\"\"get the next set of events from the event queue and, if the time of those events is different to the current time, change that time\"\"\"\n        _logger.debug(\"getting events for next timestamp\")\n        events = []\n        first_event = None\n        while True:\n            try:\n                next_item = self.event_queue.get(timeout=0)\n                t, tie_break, (event, process, causing_event) = next_item\n            except Empty:\n                break\n\n            if first_event is None:\n                first_event = event\n                if first_event.t != self.t:\n                    _logger.debug(\"time moved to %d\", first_event.t)\n                    self.t = first_event.t\n            elif event.t != first_event.t:\n                # put it back on! for the next timestep\n                self.event_queue.put((t, tie_break, (event, process, causing_event)))\n                break\n            _logger.debug(f\"added event=%s to next events batch\", repr(event))\n            events.append((event, process, causing_event))\n        _logger.debug(\"got %d events at time %d\", len(events), self.t)\n        return events\n\n    def _get_processor_event_notification_coroutines(\n        self, target_process_events_and_source_processes: list[EventSourceTargetCause]\n    ) -&gt; list[Coroutine[Any, Any, NotificationResponse]]:\n        \"\"\"create notify tasks with timeouts\"\"\"\n        tasks = []\n        for event, _, target_process, _ in target_process_events_and_source_processes:\n            tasks.append(asyncio.wait_for(target_process.notify(event), timeout=self._batch_event_notification_timeout))\n        return tasks\n\n    def _handle_unregister_events(self, events: list[QueuedEvent]):\n        \"\"\"handle the special ProcessUnregistered event\"\"\"\n        for event, process, _ in events:\n            if event.name == ProcessUnregistered.__name__:\n                self.unregister_process(process)\n\n    async def _handle_event_results(\n        self,\n        results: list[NotificationResponse | BaseException],\n        event_source_targets: list[EventSourceTargetCause],\n    ):\n        exception_to_raise = None\n        for result, (event, source_process, target_process, causing_event) in zip(results, event_source_targets):\n            _logger.debug(\n                f\"completed task notify %s of %s from %s with result %s\", target_process, event, source_process, result\n            )\n            if isinstance(result, Exception):\n                if exception_to_raise is not None:\n                    try:\n                        raise exception_to_raise\n                    except Exception:\n                        _logger.exception(\n                            \"error with %s of %s from %s with result %s\", target_process, event, source_process, result\n                        )\n                exception_to_raise = result\n                continue\n            notification_response = result\n            if not isinstance(notification_response, NotificationResponse):\n                if exception_to_raise is not None:\n                    try:\n                        raise exception_to_raise\n                    except Exception:\n                        _logger.exception(\n                            \"error with %s of %s from %s with result %s\", target_process, event, source_process, result\n                        )\n                exception_to_raise = TypeError(\n                    \"unexpected notification response. Expected NotificationResponse but got\"\n                    f\" {type(notification_response)} when sending {event} to {target_process} from {source_process}\"\n                )\n                continue\n            if self._use_no_ack_cache and result == NotificationResponse.NO_ACK:\n                self._no_ack_cache.add((event.name, str(target_process)))\n            if self._record_results:\n                key = (event, source_process.process_name, source_process.instance_identifier, causing_event)\n                try:\n                    self.event_results[key][\n                        (target_process.process_name, target_process.instance_identifier)\n                    ] = notification_response\n                except KeyError:\n                    self.event_results[key] = {\n                        (target_process.process_name, target_process.instance_identifier): notification_response\n                    }\n\n        if exception_to_raise:\n            raise exception_to_raise\n\n    async def _broadcast_events(\n        self, target_process_events_and_source_processes\n    ) -&gt; list[NotificationResponse | BaseException]:\n        processor_event_notifications = self._get_processor_event_notification_coroutines(\n            target_process_events_and_source_processes\n        )\n        return await asyncio.gather(*processor_event_notifications, return_exceptions=True)\n\n    async def step(self, until: int | None = None) -&gt; bool:\n        events_for_timestep = self._get_events_for_next_timestep()\n        if not events_for_timestep:\n            _logger.info(\"ending run as we have exhausted the queue of events!\")\n            return False\n        elif until is not None and self.t &gt; until:\n            _logger.info(\"ending run as we reached events occurring beyond the end of time (%d)!\", until)\n            return False\n\n        self._handle_unregister_events(events_for_timestep)\n        if self._record_event_history:\n            self.event_history.append(tuple(events_for_timestep))\n        target_process_events_and_source_processes = [\n            (event, source_process, target_process, cause)\n            for target_process, (event, source_process, cause) in product(self._processes, events_for_timestep)\n            if not self._use_no_ack_cache or (event.name, str(target_process)) not in self._no_ack_cache\n        ]\n        results = await self._broadcast_events(target_process_events_and_source_processes)\n        await self._handle_event_results(results, target_process_events_and_source_processes)\n\n        return True\n\n    async def run(self, until: int | None = None):\n        hades_process = HadesInternalProcess()\n        self.register_process(hades_process)\n        self.add_event(hades_process, SimulationStarted())\n        continue_running = True\n        while continue_running:\n            continue_running = await self.step(until=until)\n        self.add_event(hades_process, SimulationEnded(t=self.t))\n        # Always broadcast the SimulationEnded event.\n        # Even if we have gone beyond the end of time.\n        await self.step(until=None)\n</code></pre>"},{"location":"api_reference/hades/#hades.core.hades.Hades.__init__","title":"<code>__init__(random_pomegranate_seed='hades', max_queue_size=0, batch_event_notification_timeout=60 * 5, record_results=True, record_event_history=True, use_no_ack_cache=False, track_causing_events=False)</code>","text":"<p>Hades initialisation, specify core simulation parameters and performance optimisations</p> <p>Parameters:</p> Name Type Description Default <code>random_pomegranate_seed</code> <code>str | None</code> <p>a random seed, used to initialise process instance identifiers etc. Defaults to \"hades\".</p> <code>'hades'</code> <code>max_queue_size</code> <code>int</code> <p>how large the event queue is allowed to grow to, infinite by default. Defaults to 0.</p> <code>0</code> <code>batch_event_notification_timeout</code> <code>int | None</code> <p>how long to wait for a batch of events (at a timestep) before erroring. Defaults to 60*5.</p> <code>60 * 5</code> <code>record_results</code> <code>bool</code> <p>performance measure - whether to record process responses to events in self._event_results. Defaults to True.</p> <code>True</code> <code>record_event_history</code> <code>bool</code> <p>performance measure - whether to record event history in self.event_history. Defaults to True.</p> <code>True</code> <code>use_no_ack_cache</code> <code>bool</code> <p>performance measure - whether to stop notifying target processes of event types once they respond with a NO_ACK to one. Defaults to False.</p> <code>False</code> <code>track_causing_events</code> <code>bool</code> <p>performance measure - whether to track which events caused other events, may be useful for downstream visualisation but not required functionally. Defaults to False.</p> <code>False</code> Source code in <code>hades/core/hades.py</code> <pre><code>def __init__(\n    self,\n    random_pomegranate_seed: str | None = \"hades\",\n    max_queue_size: int = 0,\n    batch_event_notification_timeout: int | None = 60 * 5,\n    record_results: bool = True,\n    record_event_history: bool = True,\n    use_no_ack_cache: bool = False,\n    track_causing_events: bool = False,\n) -&gt; None:\n    \"\"\"Hades initialisation, specify core simulation parameters and performance optimisations\n\n    Args:\n        random_pomegranate_seed (str | None, optional): a random seed, used to initialise process instance identifiers etc. Defaults to \"hades\".\n        max_queue_size (int, optional): how large the event queue is allowed to grow to, infinite by default. Defaults to 0.\n        batch_event_notification_timeout (int | None, optional): how long to wait for a batch of events (at a timestep) before erroring. Defaults to 60*5.\n        record_results (bool, optional): performance measure - whether to record process responses to events in self._event_results. Defaults to True.\n        record_event_history (bool, optional): performance measure - whether to record event history in self.event_history. Defaults to True.\n        use_no_ack_cache (bool, optional): performance measure - whether to stop notifying target processes of event types once they respond with a NO_ACK to one. Defaults to False.\n        track_causing_events (bool, optional): performance measure - whether to track which events caused other events, may be useful for downstream visualisation but not required functionally. Defaults to False.\n    \"\"\"\n    self.random = random.Random(random_pomegranate_seed)\n    self.event_queue: PriorityQueue = PriorityQueue(maxsize=max_queue_size)\n    self.t = 0\n    self._processes: list[Process] = []\n    self._batch_event_notification_timeout = batch_event_notification_timeout\n    self.event_history: list[tuple[tuple[Event, Process, Event | None], ...]] = []\n    self.event_results: dict[tuple[Event, str, str, Event | None], dict[tuple[str, str], NotificationResponse]] = {}\n\n    self._event_count = count()\n    self._record_results = record_results\n    self._record_event_history = record_event_history\n    self._use_no_ack_cache = use_no_ack_cache\n    self._track_causing_event = track_causing_events\n    self._no_ack_cache: set[tuple[str, str]] = set()\n</code></pre>"},{"location":"api_reference/hades/#other-points-of-note","title":"Other points of note","text":"<ul> <li>Exceptions are handled by raising the last one to occur within a timestep. If there are multiple they are simply logged at <code>ERROR</code> level</li> <li>Events at the same <code>t</code> are prioritised in the order they were added to the queue, however this shouldn't make too much difference in most cases as they will be executed as part of the same <code>asyncio.gather</code> regardless.</li> </ul>"},{"location":"api_reference/process/","title":"Process","text":"<p>The entity doing the main body of work within the simulation is the <code>Process</code>. The <code>notify(event)</code> method of every process registered  (via <code>hades_instance.register_process()</code>) will be called for each event in the queue for the next time step as a group of asynchronous tasks. That is to say: events are broadcast and handled asynchronously by the registered processes.  For justification of this see the design justification.</p>"},{"location":"api_reference/process/#hades.core.process--pattern-matching-events","title":"Pattern matching events","text":"<p>The pattern suggested for processes, is for the process to <code>match</code> events that it uses and respond with some sort of acknowledgement of what was done with the event. E.g.</p> <pre><code>from hades import NotificationResponse, Hades, Event\n\nclass MyProcess(Process):\n    def __init__(self, important_identifiers: list[str]):\n        self._important_identifiers = important_identifiers\n\n    async def notify(self event: Event):\n        match event:\n            case SomeEvent(t=t, some_identifier=some_identifier, data=data):\n                if some_identifier not in important_identifiers:\n                    return NotificationResponse.ACK_BUT_IGNORED\n                data_for_other_event = self._do_something_with_data(d)\n                self.add_event(OtherEvent(t=t+1, data=data_for_other_event))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"api_reference/process/#hades.core.process--process-notifications-and-asynchronous-handling","title":"Process Notifications and Asynchronous Handling","text":"<p>The Hades Framework's core functionality involves handling and broadcasting events asynchronously.  The implementation uses Python's native asyncio library for task scheduling and execution.  All events for a given time-step are broadcast to all registered processes and handled independently within their context.</p>"},{"location":"api_reference/process/#hades.core.process--asynchronous-behaviour-and-data-consistency","title":"Asynchronous Behaviour and Data Consistency","text":"<p>However, as powerful as this design pattern may be, it also introduces a certain level of complexity when dealing with shared data resources.</p> <p>Consider the scenario where multiple events are sent to a single process, and each event triggers modifications on a shared data resource, for example, a list within the process. Since all the events are handled asynchronously and independently, the order of execution is not guaranteed, and data inconsistency can arise due to race conditions.</p> <p>This is a critical aspect of using the Hades Framework: always ensure data consistency and thread-safety when designing your processes.</p>"},{"location":"api_reference/process/#hades.core.process--managing-asynchronous-operations-within-processes","title":"Managing Asynchronous Operations within Processes","text":"<p>Here are some recommended ways to handle shared data within processes:</p> <ul> <li>Use synchronization primitives: Python's asyncio library provides several synchronization primitives like locks (asyncio.Lock()) and semaphores (asyncio.Semaphore()).  Use these primitives to ensure only one coroutine within a process modifies the shared resource at any given time.</li> <li>Immutable data structures: If possible, use immutable data structures. This eliminates the possibility of shared data being modified concurrently by different coroutines, thus avoiding race conditions.</li> <li>Avoid shared state: Whenever possible, avoid using shared state within processes. Design your processes such that they work primarily with local data (from the event).</li> </ul> <p>Note</p> <p>There is no need to worry about this between processes (as they shouldn't share mutable state), only multiple events handled within the same process.</p> <p>Example of this: <pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport asyncio\n\nfrom hades import Event, Hades, NotificationResponse, Process\n\n\nclass EventOne(Event):\n    pass\n\n\nclass EventTwo(Event):\n    pass\n\n\nclass MyProcess(Process):\n    def __init__(self):\n        super().__init__()\n        self._event_data_list = []\n\n    async def notify(self, event: Event):\n        match event:\n            case EventOne(t=t):\n                print(\"event one arrives first\")\n                await asyncio.sleep(0.1)  # Simulate a delay\n                self._event_data_list.append(\"One\")\n                return NotificationResponse.ACK\n            case EventTwo(t=t):\n                print(\"event two arrives second\")\n                await asyncio.sleep(0.05)\n                self._event_data_list.append(\"Two\")\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n\n\nclass MyLockingProcess(MyProcess):\n    def __init__(self):\n        super().__init__()\n        self.lock = asyncio.Lock()\n\n    async def notify(self, event: Event):\n        async with self.lock:\n            return await super().notify(event)\n\n\nasync def test_async_notify(capsys):\n    hades = Hades()\n\n    process = MyProcess()\n\n    hades.register_process(process)\n\n    # note these arrive at the same timestep\n    hades.add_event(process, EventOne(t=0))\n    hades.add_event(process, EventTwo(t=0))\n\n    await hades.run()\n\n    # two happens before one\n    assert process._event_data_list == [\"Two\", \"One\"]\n    # even though one arrives before two\n    assert capsys.readouterr().out == \"\"\"event one arrives first\nevent two arrives second\n\"\"\"\n\n\nasync def test_async_notify_with_lock(capsys):\n    hades = Hades()\n\n    process = MyLockingProcess()\n\n    hades.register_process(process)\n\n    hades.add_event(process, EventOne(t=0))\n    hades.add_event(process, EventTwo(t=0))\n\n    await hades.run()\n\n    # with the lock events happen in the order they arrive.\n    assert process._event_data_list == [\"One\", \"Two\"]\n    assert capsys.readouterr().out == \"\"\"event one arrives first\nevent two arrives second\n\"\"\"\n</code></pre></p>"},{"location":"api_reference/process/#hades.core.process.PredefinedEventAdder","title":"<code>PredefinedEventAdder</code>","text":"<p>             Bases: <code>Process</code></p> <p>adds some predefined events to hades then unregisters itself to avoid any overhead</p> Source code in <code>hades/core/process.py</code> <pre><code>class PredefinedEventAdder(Process):\n    \"\"\"adds some predefined events to hades then unregisters itself to avoid any overhead\"\"\"\n\n    def __init__(self, predefined_events: list[Event], name: str) -&gt; None:\n        super().__init__()\n        self._name = name\n        self._events = predefined_events\n\n    @property\n    def instance_identifier(self):\n        return self._name\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case SimulationStarted(t=t):\n                for event in self._events:\n                    self.add_event(event)\n                self.add_event(ProcessUnregistered(t=t))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"api_reference/process/#hades.core.process.Process","title":"<code>Process</code>","text":"Source code in <code>hades/core/process.py</code> <pre><code>class Process:\n    def __init__(self) -&gt; None:\n        self.add_event_to_hades: None | AddEventCallback = None\n        self._random_process_identifier: int = -1\n        self._str: str | None = None\n\n    @property\n    def process_name(self):\n        return self.__class__.__name__\n\n    @property\n    def instance_identifier(self) -&gt; str:\n        \"\"\"\n        unique identifier for the process. This does not need to be globally unique however, multiple instances of a given process_name\n        with the same instance identifier will not be allowed across the styx (into hades)\n        \"\"\"\n        return str(self._random_process_identifier)\n\n    def __str__(self) -&gt; str:\n        if self._random_process_identifier != -1:\n            return f\"process: {self.process_name}, instance: {self.instance_identifier}\"\n        if self._str is None:\n            self._str = f\"process: {self.process_name}, instance: {self.instance_identifier}\"\n        return self._str\n\n    def add_event(self, event: Event):\n        if self.add_event_to_hades is None:\n            raise ValueError(\n                f\"add event to hades callback must be set before {self.process_name} can add events to the world\"\n            )\n        self.add_event_to_hades(self, event)\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        raise NotImplementedError(f\"notify must be implemented for {self.process_name} processes\")\n</code></pre>"},{"location":"api_reference/process/#hades.core.process.Process.instance_identifier","title":"<code>instance_identifier: str</code>  <code>property</code>","text":"<p>unique identifier for the process. This does not need to be globally unique however, multiple instances of a given process_name with the same instance identifier will not be allowed across the styx (into hades)</p>"},{"location":"api_reference/process/#hades.core.process.RandomProcess","title":"<code>RandomProcess</code>","text":"<p>             Bases: <code>Process</code></p> <p>a process which adds a .random attribute with the given seed</p> Source code in <code>hades/core/process.py</code> <pre><code>class RandomProcess(Process):\n    \"\"\"a process which adds a .random attribute with the given seed\"\"\"\n\n    def __init__(self, seed: str | None) -&gt; None:\n        super().__init__()\n        self.random = random.Random(seed or self._random_process_identifier)\n\n    def _generate_uuid(self, version: int = 4) -&gt; uuid.UUID:\n        \"\"\"generate a uuid using the random seed\"\"\"\n        return uuid.UUID(int=self.random.getrandbits(128), version=version)\n</code></pre>"},{"location":"api_reference/time/","title":"Time Utilities","text":""},{"location":"api_reference/time/#hades.time","title":"<code>hades.time</code>","text":"<p>Time steps in hades can represent anything. This package contains some helper functions for common use cases particularly with time steps as days</p>"},{"location":"api_reference/time/#hades.time.QuarterStartScheduler","title":"<code>QuarterStartScheduler</code>","text":"<p>             Bases: <code>Process</code></p> <p>adds quarter start events to be used for things occurring with a quarterly cadence. Depends on the YearStarted event being broadcast to it</p> Source code in <code>hades/time/process.py</code> <pre><code>class QuarterStartScheduler(Process):\n    \"\"\"adds quarter start events to be used for things occurring with a quarterly cadence. Depends on the YearStarted event\n    being broadcast to it\"\"\"\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case YearStarted(t=t):\n                for i in range(4):\n                    self.add_event(QuarterStarted(t=datetime_to_step(date(step_to_date(t).year, (i * 3) + 1, 1))))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"api_reference/time/#hades.time.QuarterStarted","title":"<code>QuarterStarted</code>","text":"<p>             Bases: <code>Event</code></p> <p>the quarter started on this day</p> Source code in <code>hades/time/event.py</code> <pre><code>class QuarterStarted(Event):\n    \"\"\"the quarter started on this day\"\"\"\n\n    @property\n    def year(self) -&gt; int:\n        return step_to_date(self.t).year\n\n    @property\n    def quarter_number(self) -&gt; int:\n        return quarter_from_datetime(step_to_date(self.t))\n</code></pre>"},{"location":"api_reference/time/#hades.time.YearStartScheduler","title":"<code>YearStartScheduler</code>","text":"<p>             Bases: <code>Process</code></p> <p>adds year start events to be used by other processes for scheduling things which come with an annual cadence, has no dependencies in terms of other events apart from the built-in SimulationStarted</p> Source code in <code>hades/time/process.py</code> <pre><code>class YearStartScheduler(Process):\n    \"\"\"adds year start events to be used by other processes for scheduling things which come with an annual cadence,\n    has no dependencies in terms of other events apart from the built-in SimulationStarted\"\"\"\n\n    def __init__(self, start_year: int, look_ahead_years: int = 100) -&gt; None:\n        self._look_ahead_years = look_ahead_years\n        self._start_year = start_year\n        self._latest_year_added: int | None = None\n        super().__init__()\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case SimulationStarted(t=t) as e:\n                _logger.debug(\n                    \"adding look ahead YearStarted events between %d and %d due to %s\",\n                    self._start_year,\n                    self._look_ahead_years + self._start_year,\n                    repr(e),\n                )\n                for year in range(self._start_year, self._look_ahead_years + self._start_year):\n                    self.add_event(YearStarted(t=datetime_to_step(date(year, 1, 1))))\n                self._latest_year_added = self._look_ahead_years + self._start_year - 1\n                return NotificationResponse.ACK\n            case YearStarted():\n                return NotificationResponse.ACK_BUT_IGNORED\n            case QuarterStarted():\n                return NotificationResponse.ACK_BUT_IGNORED\n            case Event(t=t) as e:\n                # ensure that we keep the look ahead window maintained given other events\n                if (\n                    self._latest_year_added is not None\n                    and (current_year := step_to_date(t).year) &gt; self._latest_year_added - self._look_ahead_years + 1\n                ):\n                    _logger.debug(\n                        \"adding look ahead YearStarted events between %d and %d due to %s\",\n                        self._latest_year_added + 1,\n                        current_year + self._look_ahead_years,\n                        repr(e),\n                    )\n                    for year in range(self._latest_year_added + 1, current_year + self._look_ahead_years):\n                        self.add_event(YearStarted(t=datetime_to_step(date(year, 1, 1))))\n                        self._latest_year_added = year\n\n                    return NotificationResponse.ACK\n                return NotificationResponse.ACK_BUT_IGNORED\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"api_reference/time/#hades.time.YearStarted","title":"<code>YearStarted</code>","text":"<p>             Bases: <code>Event</code></p> <p>the year started on this day (e.g. 1/1)</p> Source code in <code>hades/time/event.py</code> <pre><code>class YearStarted(Event):\n    \"\"\"the year started on this day (e.g. 1/1)\"\"\"\n\n    @property\n    def year(self) -&gt; int:\n        return step_to_date(self.t).year\n\n    @property\n    def is_leap(self) -&gt; bool:\n        return calendar.isleap(self.year)\n\n    @property\n    def number_of_days(self) -&gt; int:\n        return 365 + int(self.is_leap)\n</code></pre>"},{"location":"api_reference/time/#hades.time.datetime_to_step","title":"<code>datetime_to_step(dt, epoch=EPOCH)</code>","text":"<p>datetime or date as days since epoch</p> Source code in <code>hades/time/day_steps.py</code> <pre><code>def datetime_to_step(dt: Union[datetime, date], epoch: datetime = EPOCH) -&gt; int:\n    \"\"\"datetime or date as days since epoch\"\"\"\n    if not isinstance(dt, datetime):\n        return datetime_to_step(datetime.fromisoformat(dt.isoformat()))\n    return int((dt - epoch).total_seconds() // timedelta(days=1).total_seconds())\n</code></pre>"},{"location":"api_reference/time/#hades.time.step_to_date","title":"<code>step_to_date(step)</code>","text":"<p>days since epoch as date</p> Source code in <code>hades/time/day_steps.py</code> <pre><code>def step_to_date(step: int) -&gt; date:\n    \"\"\"days since epoch as date\"\"\"\n    return step_to_datetime(step).date()\n</code></pre>"},{"location":"api_reference/time/#hades.time.step_to_datetime","title":"<code>step_to_datetime(step, epoch=EPOCH)</code>","text":"<p>days since epoch as datetime</p> Source code in <code>hades/time/day_steps.py</code> <pre><code>def step_to_datetime(step: int, epoch: datetime = EPOCH) -&gt; datetime:\n    \"\"\"days since epoch as datetime\"\"\"\n    return epoch + timedelta(days=step)\n</code></pre>"},{"location":"api_reference/time/#hades.time.event","title":"<code>hades.time.event</code>","text":""},{"location":"api_reference/time/#hades.time.event.QuarterStarted","title":"<code>QuarterStarted</code>","text":"<p>             Bases: <code>Event</code></p> <p>the quarter started on this day</p> Source code in <code>hades/time/event.py</code> <pre><code>class QuarterStarted(Event):\n    \"\"\"the quarter started on this day\"\"\"\n\n    @property\n    def year(self) -&gt; int:\n        return step_to_date(self.t).year\n\n    @property\n    def quarter_number(self) -&gt; int:\n        return quarter_from_datetime(step_to_date(self.t))\n</code></pre>"},{"location":"api_reference/time/#hades.time.event.YearStarted","title":"<code>YearStarted</code>","text":"<p>             Bases: <code>Event</code></p> <p>the year started on this day (e.g. 1/1)</p> Source code in <code>hades/time/event.py</code> <pre><code>class YearStarted(Event):\n    \"\"\"the year started on this day (e.g. 1/1)\"\"\"\n\n    @property\n    def year(self) -&gt; int:\n        return step_to_date(self.t).year\n\n    @property\n    def is_leap(self) -&gt; bool:\n        return calendar.isleap(self.year)\n\n    @property\n    def number_of_days(self) -&gt; int:\n        return 365 + int(self.is_leap)\n</code></pre>"},{"location":"api_reference/time/#hades.time.day_steps","title":"<code>hades.time.day_steps</code>","text":""},{"location":"api_reference/time/#hades.time.day_steps.datetime_to_step","title":"<code>datetime_to_step(dt, epoch=EPOCH)</code>","text":"<p>datetime or date as days since epoch</p> Source code in <code>hades/time/day_steps.py</code> <pre><code>def datetime_to_step(dt: Union[datetime, date], epoch: datetime = EPOCH) -&gt; int:\n    \"\"\"datetime or date as days since epoch\"\"\"\n    if not isinstance(dt, datetime):\n        return datetime_to_step(datetime.fromisoformat(dt.isoformat()))\n    return int((dt - epoch).total_seconds() // timedelta(days=1).total_seconds())\n</code></pre>"},{"location":"api_reference/time/#hades.time.day_steps.step_to_date","title":"<code>step_to_date(step)</code>","text":"<p>days since epoch as date</p> Source code in <code>hades/time/day_steps.py</code> <pre><code>def step_to_date(step: int) -&gt; date:\n    \"\"\"days since epoch as date\"\"\"\n    return step_to_datetime(step).date()\n</code></pre>"},{"location":"api_reference/time/#hades.time.day_steps.step_to_datetime","title":"<code>step_to_datetime(step, epoch=EPOCH)</code>","text":"<p>days since epoch as datetime</p> Source code in <code>hades/time/day_steps.py</code> <pre><code>def step_to_datetime(step: int, epoch: datetime = EPOCH) -&gt; datetime:\n    \"\"\"days since epoch as datetime\"\"\"\n    return epoch + timedelta(days=step)\n</code></pre>"},{"location":"api_reference/time/#hades.time.process","title":"<code>hades.time.process</code>","text":""},{"location":"api_reference/time/#hades.time.process.QuarterStartScheduler","title":"<code>QuarterStartScheduler</code>","text":"<p>             Bases: <code>Process</code></p> <p>adds quarter start events to be used for things occurring with a quarterly cadence. Depends on the YearStarted event being broadcast to it</p> Source code in <code>hades/time/process.py</code> <pre><code>class QuarterStartScheduler(Process):\n    \"\"\"adds quarter start events to be used for things occurring with a quarterly cadence. Depends on the YearStarted event\n    being broadcast to it\"\"\"\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case YearStarted(t=t):\n                for i in range(4):\n                    self.add_event(QuarterStarted(t=datetime_to_step(date(step_to_date(t).year, (i * 3) + 1, 1))))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"api_reference/time/#hades.time.process.YearStartScheduler","title":"<code>YearStartScheduler</code>","text":"<p>             Bases: <code>Process</code></p> <p>adds year start events to be used by other processes for scheduling things which come with an annual cadence, has no dependencies in terms of other events apart from the built-in SimulationStarted</p> Source code in <code>hades/time/process.py</code> <pre><code>class YearStartScheduler(Process):\n    \"\"\"adds year start events to be used by other processes for scheduling things which come with an annual cadence,\n    has no dependencies in terms of other events apart from the built-in SimulationStarted\"\"\"\n\n    def __init__(self, start_year: int, look_ahead_years: int = 100) -&gt; None:\n        self._look_ahead_years = look_ahead_years\n        self._start_year = start_year\n        self._latest_year_added: int | None = None\n        super().__init__()\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case SimulationStarted(t=t) as e:\n                _logger.debug(\n                    \"adding look ahead YearStarted events between %d and %d due to %s\",\n                    self._start_year,\n                    self._look_ahead_years + self._start_year,\n                    repr(e),\n                )\n                for year in range(self._start_year, self._look_ahead_years + self._start_year):\n                    self.add_event(YearStarted(t=datetime_to_step(date(year, 1, 1))))\n                self._latest_year_added = self._look_ahead_years + self._start_year - 1\n                return NotificationResponse.ACK\n            case YearStarted():\n                return NotificationResponse.ACK_BUT_IGNORED\n            case QuarterStarted():\n                return NotificationResponse.ACK_BUT_IGNORED\n            case Event(t=t) as e:\n                # ensure that we keep the look ahead window maintained given other events\n                if (\n                    self._latest_year_added is not None\n                    and (current_year := step_to_date(t).year) &gt; self._latest_year_added - self._look_ahead_years + 1\n                ):\n                    _logger.debug(\n                        \"adding look ahead YearStarted events between %d and %d due to %s\",\n                        self._latest_year_added + 1,\n                        current_year + self._look_ahead_years,\n                        repr(e),\n                    )\n                    for year in range(self._latest_year_added + 1, current_year + self._look_ahead_years):\n                        self.add_event(YearStarted(t=datetime_to_step(date(year, 1, 1))))\n                        self._latest_year_added = year\n\n                    return NotificationResponse.ACK\n                return NotificationResponse.ACK_BUT_IGNORED\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"api_reference/time/#hades.time.logging","title":"<code>hades.time.logging</code>","text":""},{"location":"api_reference/visualisation/","title":"Visualisation Utilities","text":""},{"location":"api_reference/visualisation/#hades.visualisation.websockets","title":"<code>hades.visualisation.websockets</code>","text":"<p>output events or event results to websockets for live visualisation using custom frontend TS/JS code or other clients</p>"},{"location":"api_reference/visualisation/#hades.visualisation.websockets.EventContext","title":"<code>EventContext</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>full details of an event notification's result</p> Source code in <code>hades/visualisation/websockets.py</code> <pre><code>class EventContext(BaseModel):\n    \"\"\"full details of an event notification's result\"\"\"\n\n    source_process: ProcessDetails\n    target_process: ProcessDetails\n    event: EventWithType\n    target_process_response: NotificationResponse\n    causing_event: EventWithType | None = None\n</code></pre>"},{"location":"api_reference/visualisation/#hades.visualisation.websockets.HadesWS","title":"<code>HadesWS</code>","text":"<p>             Bases: <code>Hades</code></p> <p>Hades with a websocket server bundled. Waits for at least one client to connect before starting the simulation</p> Source code in <code>hades/visualisation/websockets.py</code> <pre><code>class HadesWS(Hades):\n    \"\"\"Hades with a websocket server bundled. Waits for at least one client to connect before starting the simulation\"\"\"\n\n    def __init__(\n        self,\n        random_pomegranate_seed: str | None = \"hades\",\n        max_queue_size: int = 0,\n        batch_event_notification_timeout: int | None = 60 * 5,\n        record_results: bool = True,\n        record_event_history: bool = True,\n        use_no_ack_cache: bool = False,\n        track_causing_events: bool = True,\n        ws_server_host: str = \"localhost\",\n        ws_server_port: int = 8765,\n        ws_server=None,\n    ) -&gt; None:\n        super().__init__(\n            random_pomegranate_seed,\n            max_queue_size,\n            batch_event_notification_timeout,\n            record_results,\n            record_event_history,\n            use_no_ack_cache,\n            track_causing_events,\n        )\n        self._ws_server_host = ws_server_host\n        self._ws_server_port = ws_server_port\n        self._ws_server = ws_server\n        self._ws_clients: set[Any] = set()\n\n    async def ws_server(self, websocket):\n        \"\"\"received client messages\"\"\"\n        self._ws_clients.add(websocket)\n        while True:\n            try:\n                message = await websocket.recv()\n                _logger.debug(\"received message: %s from ws client\", message)\n            except ConnectionClosed:\n                break\n\n    async def _handle_event_results(\n        self,\n        results: list[NotificationResponse | BaseException],\n        event_source_targets: list[EventSourceTargetCause],\n    ):\n        \"\"\"asynchronously rebroadcast all event results to all ws clients\"\"\"\n        rebroadcast_ws_events = []\n        for result, (event, source_process, target_process, causing_event) in zip(results, event_source_targets):\n            if isinstance(result, NotificationResponse):\n                for client in self._ws_clients:\n                    rebroadcast_ws_events.append(\n                        asyncio.wait_for(\n                            client.send(\n                                EventContext(\n                                    source_process=ProcessDetails.model_construct(\n                                        process_name=source_process.process_name,\n                                        instance_identifier=source_process.instance_identifier,\n                                    ),\n                                    target_process=ProcessDetails.model_construct(\n                                        process_name=target_process.process_name,\n                                        instance_identifier=target_process.instance_identifier,\n                                    ),\n                                    event=EventWithType(event_type=event.name, event_contents=event),\n                                    target_process_response=result,\n                                    causing_event=(\n                                        None\n                                        if causing_event is None\n                                        else EventWithType(event_type=causing_event.name, event_contents=causing_event)\n                                    ),\n                                ).model_dump_json()\n                            ),\n                            timeout=self._batch_event_notification_timeout,\n                        )\n                    )\n        await asyncio.gather(*rebroadcast_ws_events)\n        await super()._handle_event_results(results, event_source_targets)\n\n    async def run(self, until: int | None = None):\n        \"\"\"start a server if none is injected and wait for a client connection\"\"\"\n        # Start WebSocket server\n        if self._ws_server is None:\n            self._ws_server = await websockets.serve(self.ws_server, self._ws_server_host, self._ws_server_port)  # type: ignore\n\n        # Wait for at least one client to connect\n        while not self._ws_clients:\n            await asyncio.sleep(1)  # Wait for 1 second before checking again\n        await super().run(until=until)\n        self._ws_server.close()\n        await self._ws_server.wait_closed()\n</code></pre>"},{"location":"api_reference/visualisation/#hades.visualisation.websockets.HadesWS.run","title":"<code>run(until=None)</code>  <code>async</code>","text":"<p>start a server if none is injected and wait for a client connection</p> Source code in <code>hades/visualisation/websockets.py</code> <pre><code>async def run(self, until: int | None = None):\n    \"\"\"start a server if none is injected and wait for a client connection\"\"\"\n    # Start WebSocket server\n    if self._ws_server is None:\n        self._ws_server = await websockets.serve(self.ws_server, self._ws_server_host, self._ws_server_port)  # type: ignore\n\n    # Wait for at least one client to connect\n    while not self._ws_clients:\n        await asyncio.sleep(1)  # Wait for 1 second before checking again\n    await super().run(until=until)\n    self._ws_server.close()\n    await self._ws_server.wait_closed()\n</code></pre>"},{"location":"api_reference/visualisation/#hades.visualisation.websockets.HadesWS.ws_server","title":"<code>ws_server(websocket)</code>  <code>async</code>","text":"<p>received client messages</p> Source code in <code>hades/visualisation/websockets.py</code> <pre><code>async def ws_server(self, websocket):\n    \"\"\"received client messages\"\"\"\n    self._ws_clients.add(websocket)\n    while True:\n        try:\n            message = await websocket.recv()\n            _logger.debug(\"received message: %s from ws client\", message)\n        except ConnectionClosed:\n            break\n</code></pre>"},{"location":"api_reference/visualisation/#hades.visualisation.websockets.WebSocketProcess","title":"<code>WebSocketProcess</code>","text":"<p>             Bases: <code>Process</code></p> <p>simple process which sends all the events it receives as JSON to a websockets server this could be used for visualisation or monitoring</p> Source code in <code>hades/visualisation/websockets.py</code> <pre><code>class WebSocketProcess(Process):\n    \"\"\"simple process which sends all the events it receives as JSON to a websockets server\n    this could be used for visualisation or monitoring\n    \"\"\"\n\n    def __init__(self, websocket_connection) -&gt; None:\n        self._connection = websocket_connection\n        super().__init__()\n\n    async def _send_event(self, event: Event):\n        await self._connection.send(\n            EventWithType.model_construct(event_type=event.name, event_contents=event).model_dump_json()\n        )\n\n    async def notify(self, event: Event):\n        match event:\n            case Event() as e:\n                await self._send_event(event)\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"api_reference/visualisation/#hades.visualisation.networkx","title":"<code>hades.visualisation.networkx</code>","text":""},{"location":"api_reference/visualisation/#hades.visualisation.networkx.to_digraph","title":"<code>to_digraph(underworld, allowed_responses=None)</code>","text":"<p>build from hades's event_results object the full set of connections as a networkx digraph</p> Source code in <code>hades/visualisation/networkx.py</code> <pre><code>def to_digraph(underworld: Hades, allowed_responses: set[NotificationResponse] | None = None) -&gt; MultiDiGraph:\n    \"\"\"build from hades's event_results object the full set of connections as a networkx digraph\"\"\"\n    if allowed_responses is None:\n        allowed_responses = {NotificationResponse.ACK}\n    graph = MultiDiGraph()\n    added_edges: set[tuple[str, str, str]] = set()\n    for (event, source_process_name, source_process_instance_id, _), event_notifications in sorted(\n        underworld.event_results.items(), key=lambda x: x[0][0].t\n    ):\n        source_node = f\"{source_process_name} - {source_process_instance_id}\"\n        graph.add_node(source_node)\n        for (target_process_name, target_process_instance_id), notification_response in event_notifications.items():\n            target_node = f\"{target_process_name} - {target_process_instance_id}\"\n            graph.add_node(target_node)\n            if notification_response in allowed_responses and (source_node, target_node, event.name) not in added_edges:\n                graph.add_edge(source_node, target_node, label=event.name)\n                added_edges.add((source_node, target_node, event.name))\n    return graph\n</code></pre>"},{"location":"api_reference/visualisation/#hades.visualisation.networkx.write_mermaid","title":"<code>write_mermaid(G)</code>","text":"<p>output a networkx digraph as a simple mermaid graph</p> Source code in <code>hades/visualisation/networkx.py</code> <pre><code>def write_mermaid(G: MultiDiGraph) -&gt; str:\n    \"\"\"output a networkx digraph as a simple mermaid graph\"\"\"\n    lines = []\n    for u_node, v_node, edge in sorted(G.edges(data=True), key=lambda x: x[0] + x[1] + x[2][\"label\"]):\n        lines.append(f\"{u_node.replace(' ', '')}({u_node}) -- {edge['label']} --&gt; {v_node.replace(' ', '')}({v_node})\")\n    mermaid_lines = \"\\n\".join(lines)\n    return f\"graph LR\\n{mermaid_lines}\"\n</code></pre>"},{"location":"examples/battery-charging-station/","title":"Battery Charging Station","text":"<p>This example highlights some interesting differences between hades and the wonderful simpy based on their Shared Resources example.</p> <p>The key things to note are that the queue of waiting cars happens in a process rather than making use of a shared resource.</p> <p>This means the state of the battery charging station contains some useful information (and the state can be interrogated after the simulation is run etc), but results in slightly less terse code and more logic within it.</p> <pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport asyncio\n\nfrom hades import Event, Hades, NotificationResponse, PredefinedEventAdder, Process\n\n\nclass CarArrives(Event):\n    car_id: int\n\n\nclass CarStartsCharging(Event):\n    car_id: int\n\n\nclass CarLeaves(Event):\n    car_id: int\n\n\nclass BatteryChargingStation(Process):\n    def __init__(self, charging_duration: int):\n        super().__init__()\n        self.charging_duration = charging_duration\n        self.currently_charging = set()\n        self.waiting_cars = []\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case CarArrives(t=t, car_id=car_id):\n                print(f\"Car {car_id} arriving at {t}\")\n                if len(self.currently_charging) &lt; 2:\n                    self.currently_charging.add(car_id)\n                    self.add_event(CarStartsCharging(t=t, car_id=car_id))\n                else:\n                    self.waiting_cars.append(car_id)\n                return NotificationResponse.ACK\n            case CarStartsCharging(t=t, car_id=car_id):\n                print(f\"Car {car_id} starting to charge at {t}\")\n                self.add_event(CarLeaves(t=t + self.charging_duration, car_id=car_id))\n                return NotificationResponse.ACK\n            case CarLeaves(t=t, car_id=car_id):\n                print(f\"Car {car_id} leaving the bcs at {t}\")\n                self.currently_charging.remove(car_id)\n                if self.waiting_cars:\n                    next_car = self.waiting_cars.pop(0)\n                    self.currently_charging.add(next_car)\n                    self.add_event(CarStartsCharging(t=t, car_id=next_car))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n\n\nasync def bcs():\n    hades = Hades()\n    bcs = BatteryChargingStation(charging_duration=5)\n    hades.register_process(bcs)\n\n    # Creating events for cars arriving at the battery charging station\n    events: list[CarArrives] = [CarArrives(t=2 * i, car_id=i) for i in range(4)]\n    event_adder = PredefinedEventAdder(predefined_events=events, name=\"car arrivals\")\n    hades.register_process(event_adder)\n    await hades.run()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(bcs())\n</code></pre>"},{"location":"examples/battery-charging-station/#output","title":"Output","text":"<p>The output will look the same as in the simpy example but is arrived at in a different way!</p> <pre><code>Car 0 arriving at 0\nCar 0 starting to charge at 0\nCar 1 arriving at 2\nCar 1 starting to charge at 2\nCar 2 arriving at 4\nCar 0 leaving the bcs at 5\nCar 2 starting to charge at 5\nCar 3 arriving at 6\nCar 1 leaving the bcs at 7\nCar 3 starting to charge at 7\nCar 2 leaving the bcs at 10\nCar 3 leaving the bcs at 12\n</code></pre>"},{"location":"examples/boids/","title":"Boids and Visualisation","text":""},{"location":"examples/boids/#overview","title":"Overview","text":"<p>Let's build the classic artificial life program by Craig Reynolds with some worm embellishments. Taking some implementation points and using the boid on canvas drawing implementation from the amazing Ben Eater.</p> <p>We will also demonstrate a couple of visualisation techniques:</p> <ol> <li>using websockets to visualise the simulation and the events in it live via a javascript frontend</li> <li>using the state of a process to build a visualisation</li> </ol>"},{"location":"examples/boids/#results","title":"Results","text":"<ol> <li>We end up with a simulation continuing forever like this:          Note we dont have that many boids (as outputing to websockets slows stuff down a bit), but we do have a nice visualisation of the sim structure and this is very extensible</li> <li>We end up being able to run the simulation with a lot more boids and then after 1000 timesteps, we use the history collected in memory to render it. See the rendered result below</li> </ol>"},{"location":"examples/boids/#core-simulation","title":"Core simulation","text":"<p>The core simulation processes and events. In this implementation there is no shared state so each boid maintains its own view of where other boids are. We also add a processes for involving worms in the simulation! </p> Processes and Events code <pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport asyncio\nimport json\nimport logging\nimport sys\nfrom typing import Union\n\nfrom pydantic import BaseModel, ConfigDict\n\nfrom hades import Event, Hades, NotificationResponse, PredefinedEventAdder, Process\nfrom hades.visualisation.websockets import HadesWS\n\n_logger = logging.getLogger(__name__)\n\n\nclass WormPopsHisHeadUp(Event):\n    worm_id: int\n    worm_position: tuple[int, int]\n\n\nclass WormHid(Event):\n    worm_id: int\n\n\nclass WormEaten(Event):\n    worm_id: int\n    boid_id: int\n\n\nclass BoidMovement(BaseModel):\n    position: tuple[int, int]\n    velocity: tuple[float, float]\n\n    def distance(self, other: Union[\"BoidMovement\", tuple[int, int]]) -&gt; float:\n        if isinstance(other, BoidMovement):\n            ox, oy = other.position\n        else:\n            ox, oy = other\n        dx = self.position[0] - ox\n        dy = self.position[1] - oy\n        return (dx**2 + dy**2) ** (1 / 2)\n\n    @property\n    def speed(self) -&gt; float:\n        return (self.velocity[0] ** 2 + self.velocity[1] ** 2) ** (1 / 2)\n\n    def move(self, grid_size: tuple[int, int]):\n        x, y = self.position\n        vx, vy = self.velocity\n        self.position = (int(x + vx) % grid_size[0], int(y + vy) % grid_size[1])\n\n\nclass ImmutableMovement(BoidMovement):\n    model_config = ConfigDict(frozen=True)\n\n\nclass BoidMoved(Event):\n    boid_id: int\n    movement: ImmutableMovement\n\n\nclass WormHider(Process):\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case WormPopsHisHeadUp(t=t, worm_id=worm_id):\n                self.add_event(WormHid(t=t + 100, worm_id=worm_id))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n\n\nclass Boid(Process):\n    def __init__(self, boid_identifier: int, grid_size: tuple[int, int]) -&gt; None:\n        self._grid_size = grid_size\n        self._boid_identifier = boid_identifier\n        self._movement: BoidMovement | None = None\n        self._other_boid_positions: dict[int, BoidMovement] = {}\n\n        self._visual_range = 100\n        self._worm_eat_distance = 8\n\n        self._target_worm: tuple[int, tuple[int, int]] | None = None\n\n        super().__init__()\n\n    @property\n    def instance_identifier(self):\n        return self._boid_identifier\n\n    def _ensure_seperation(self):\n        \"\"\"separation: steer to avoid crowding local flockmates\"\"\"\n        if not self._movement:\n            return\n        seperation_factor = 0.05\n        min_distance = 20\n        move_x, move_y = 0, 0\n        for other_boid_id, other_boid_position in self._other_boid_positions.items():\n            if other_boid_id != self._boid_identifier:\n                if self._movement.distance(other_boid_position) &lt; min_distance:\n                    move_x += self._movement.position[0] - other_boid_position.position[0]\n                    move_y += self._movement.position[1] - other_boid_position.position[1]\n        self._movement.velocity = (\n            self._movement.velocity[0] + (move_x * seperation_factor),\n            self._movement.velocity[1] + (move_y * seperation_factor),\n        )\n\n    def _align(self):\n        \"\"\"alignment: steer towards the average heading of local flockmates\"\"\"\n        if not self._movement:\n            return\n        align_factor = 0.02\n        average_vx, average_vy, num_neighbours = 0, 0, 0\n        for other_boid in self._other_boid_positions.values():\n            if self._movement.distance(other_boid) &lt; self._visual_range:\n                average_vx += other_boid.velocity[0]\n                average_vy += other_boid.velocity[1]\n                num_neighbours += 1\n        try:\n            self._movement.velocity = (\n                self._movement.velocity[0]\n                + ((average_vx / num_neighbours) - self._movement.velocity[0]) * align_factor,\n                self._movement.velocity[1]\n                + ((average_vy / num_neighbours) - self._movement.velocity[1]) * align_factor,\n            )\n        except ZeroDivisionError:\n            return\n\n    def _cohere(self):\n        \"\"\"cohesion: steer to move towards the average position (center of mass) of local flockmates\"\"\"\n        if not self._movement:\n            return\n        coherence_factor = 0.002\n        average_x, average_y = self._movement.position\n        count_near = 0\n        for movement in self._other_boid_positions.values():\n            if self._movement.distance(movement) &lt; self._visual_range:\n                average_x += movement.position[0]\n                average_y += movement.position[1]\n                count_near += 1\n        if count_near == 0:\n            return\n        center_x = average_x / count_near\n        center_y = average_y / count_near\n        self._movement.velocity = (\n            self._movement.velocity[0] + (center_x - self._movement.position[0]) * coherence_factor,\n            self._movement.velocity[1] + (center_y - self._movement.position[1]) * coherence_factor,\n        )\n\n    def _move_to_target_worm(self):\n        if not self._movement or not self._target_worm:\n            return\n        worm_attraction = 0.01\n\n        _, (worm_x, worm_y) = self._target_worm\n\n        self._movement.velocity = (\n            self._movement.velocity[0] + (worm_x - self._movement.position[0]) * worm_attraction,\n            self._movement.velocity[1] + (worm_y - self._movement.position[1]) * worm_attraction,\n        )\n\n    def _keep_within_bounds(self):\n        if not self._movement:\n            return\n        margin = self._grid_size[0] // 5\n        turnFactor = 2\n\n        velocity_x = self._movement.velocity[0]\n        velocity_y = self._movement.velocity[1]\n\n        if self._movement.position[0] &lt; margin:\n            velocity_x += turnFactor\n\n        if self._movement.position[0] &gt; self._grid_size[0] - margin:\n            velocity_x -= turnFactor\n\n        if self._movement.position[1] &lt; margin:\n            velocity_y += turnFactor\n\n        if self._movement.position[1] &gt; self._grid_size[1] - margin:\n            velocity_y -= turnFactor\n\n        self._movement.velocity = (velocity_x, velocity_y)\n\n    def _slow_down(self):\n        if not self._movement:\n            return\n        vx, vy = self._movement.velocity\n        speed = self._movement.speed\n        max_speed = 10\n        if speed &lt; max_speed:\n            return\n\n        self._movement.velocity = (max_speed * (vx / speed), max_speed * (vy / speed))\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case BoidMoved(t=t, boid_id=boid_id, movement=movement):\n                self._other_boid_positions[boid_id] = movement\n                if boid_id == self._boid_identifier:\n                    # We will only get this once per time step so its our opportunity to move!\n                    if not self._movement:\n                        self._movement = BoidMovement(**movement.dict())\n                    self._move_to_target_worm()\n                    self._cohere()\n                    self._ensure_seperation()\n                    self._align()\n                    self._slow_down()\n                    self._movement.move(grid_size=self._grid_size)\n                    if self._target_worm:\n                        worm_id, worm_position = self._target_worm\n                        if self._movement.distance(worm_position) &lt; self._worm_eat_distance:\n                            _logger.info(f\"worm {worm_id} eaten by boid {self._boid_identifier}\")\n                            self.add_event(\n                                WormEaten(\n                                    t=t + 1,\n                                    worm_id=worm_id,\n                                    boid_id=self._boid_identifier,\n                                )\n                            )\n                    self.add_event(\n                        BoidMoved(t=t + 1, boid_id=boid_id, movement=ImmutableMovement(**self._movement.dict()))\n                    )\n                return NotificationResponse.ACK\n            case WormPopsHisHeadUp(t=t, worm_position=position, worm_id=worm_id):\n                if self._movement and self._movement.distance(position) &lt; self._visual_range * 2:\n                    _logger.info(f\"worm {worm_id} being targeted by {self._boid_identifier}\")\n                    self._target_worm = (worm_id, position)\n                return NotificationResponse.ACK\n            case WormEaten(worm_id=worm_id) | WormHid(worm_id=worm_id):\n                if self._target_worm and self._target_worm[0] == worm_id:\n                    self._target_worm = None\n                    return NotificationResponse.ACK\n                return NotificationResponse.ACK_BUT_IGNORED\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"examples/boids/#visualising-live-simulation-using-websockets","title":"Visualising Live Simulation Using Websockets","text":""},{"location":"examples/boids/#simulation-with-hadesws","title":"Simulation with HadesWS","text":"<p>First lets put the processes of our simulation together as follows, note that in websockets mode we use <code>HadesWS</code></p> Simulation Setup Code <pre><code>    num_boids = 10 if use_websockets else 50\n    grid_size = (1000, 1000)\n    if use_websockets:\n        hades = HadesWS(\n            random_pomegranate_seed=\"Reynolds\", record_results=False, use_no_ack_cache=True, record_event_history=False\n        )\n    else:\n        hades = Hades(\n            random_pomegranate_seed=\"Reynolds\", record_results=False, use_no_ack_cache=True, record_event_history=False\n        )\n    hades.register_process(\n        process=PredefinedEventAdder(\n            predefined_events=[\n                BoidMoved(\n                    t=0,\n                    boid_id=i,\n                    movement=ImmutableMovement(position=(500 - i, 500 + i), velocity=(-1 - (0.1 * i), 1 + (0.1 * i))),\n                )\n                for i in range(num_boids)\n            ],\n            name=\"add boids\",\n        )\n    )\n    hades.register_process(\n        PredefinedEventAdder(\n            predefined_events=[\n                WormPopsHisHeadUp(\n                    worm_id=i,\n                    t=i,\n                    worm_position=(\n                        hades.random.randint(0, grid_size[0] - 1),\n                        hades.random.randint(0, grid_size[1] - 1),\n                    ),\n                )\n                for i in range(0, 1000, 50 if use_websockets else 5)\n            ],\n            name=\"worm spawner\",\n        )\n    )\n    hades.register_process(WormHider())\n    for i in range(num_boids):\n        hades.register_process(Boid(boid_identifier=i, grid_size=(1000, 1000)))\n\n    if not use_websockets:\n        movement_history = BoidMovementHistory(grid_size=(1000, 1000))\n        hades.register_process(movement_history)\n    await hades.run(until=run_till)\n\n    if not use_websockets:\n        with open(\"boids.html\", \"w\") as f:\n            f.write(movement_history.create_html_file())\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n\n    asyncio.run(run_sim(len(sys.argv) &gt; 1 and sys.argv[1] == \"websockets\"))\n</code></pre>"},{"location":"examples/boids/#frontend","title":"Frontend","text":"<p>On our frontend we want to visualise two things:</p> <ol> <li>the live graph of how events connect to processes </li> <li>the actual flocking behaviour</li> </ol> <p>To do this we list to the websockets server and render 1. using <code>d3.js</code> and 2. using <code>canvas</code>.</p> <p>Note that if we were just looking at the events to simulate the flock me would get better performance out of <code>WebSocketProcess</code></p> Frontend Code <pre><code>&lt;head&gt;\n    &lt;title&gt;Boids&lt;/title&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js\"\n        integrity=\"sha512-M7nHCiNUOwFt6Us3r8alutZLm9qMt4s9951uo8jqO4UwJ1hziseL6O3ndFyigx6+LREfZqnhHxYjKRJ8ZQ69DQ==\"\n        crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        body {\n            font-family: Arial, Helvetica, sans-serif;\n        }\n\n        div {\n            display: inline-block;\n        }\n\n        svg,\n        canvas {\n            border: 1px solid black;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div&gt;\n        &lt;h3&gt;Live Boids&lt;/h3&gt;\n        &lt;canvas id=\"boids-canvas\" width=\"1000\" height=\"1000\"&gt;&lt;/canvas&gt;\n    &lt;/div&gt;\n    &lt;div id=\"graph-container\"&gt;\n        &lt;h3&gt;Live Event Process Graph&lt;/h3&gt;\n    &lt;/div&gt;\n    &lt;footer&gt;t=0&lt;/footer&gt;\n\n    &lt;script&gt;\n        let nodes = [];\n        let links = [];\n\n\n\n        // Prepare SVG container for the graph\n        const svg = d3.select(\"#graph-container\")\n            .append(\"svg\")\n            .attr(\"width\", 1000)\n            .attr(\"height\", 1000);\n\n        // Initialize simulation\n        const simulation = d3.forceSimulation()\n            .force(\"link\", d3.forceLink(links).id(x =&gt; x.id).distance(100))\n            .force(\"charge\", d3.forceManyBody(-500))\n            .force(\"collide\", d3.forceCollide(50))\n            .force(\"center\", d3.forceCenter(800 / 2, 1000 / 2));\n\n        let t = 0;\n\n        // Update graph based on new data\n        function updateGraph(data) {\n            let doDraw = false;\n            // Check for new nodes and add them to the nodes array\n            let sourceNode = nodes.find(node =&gt; node.id === data.source_process.process_name)\n            t = Math.max(t, data.event.event_contents.t)\n            document.getElementsByTagName(\"footer\")[0].innerHTML = `t=${t}`\n            if (sourceNode === undefined) {\n                sourceNode = { id: data.source_process.process_name, type: 'process', lastActive: t }\n            } else {\n                sourceNode.lastActive = t\n            }\n            if (!sourceNode.index) {\n                nodes.push(sourceNode);\n                doDraw = true\n            }\n            let targetNode = nodes.find(node =&gt; node.id === data.target_process.process_name)\n            if (targetNode === undefined) {\n                targetNode = { id: data.target_process.process_name, type: 'process', lastActive: t }\n            } else {\n                targetNode.lastActive = t\n            }\n            if (!targetNode.index) {\n                nodes.push(targetNode);\n                doDraw = true\n            }\n            let eventNode = nodes.find(node =&gt; node.id === data.event.event_type)\n            if (eventNode === undefined) {\n                eventNode = { id: data.event.event_type, type: 'event', lastActive: t }\n            } else[\n                eventNode.lastActive = t\n            ]\n            if (!eventNode.index) {\n                nodes.push(eventNode);\n                doDraw = true\n            }\n\n            // Check for new links and add them to the links array\n            const sourceLink = {\n                source: sourceNode,\n                target: eventNode,\n                highlight: true,\n                lastActive: t,\n                value: 1\n            };\n\n            const targetLink = {\n                source: eventNode,\n                target: targetNode,\n                highlight: true,\n                lastActive: t,\n                value: 1\n            };\n            doDraw = true\n            for (const link of [sourceLink, targetLink]) {\n                const existingLink = links.find(l =&gt; l.source.id === link.source.id &amp;&amp; l.target.id === link.target.id)\n\n                if (existingLink === undefined) {\n                    links.push(link);\n                }\n                else {\n                    existingLink.lastActive = t\n                }\n            }\n            if (doDraw) {\n                drawGraph()\n            }\n        }\n\n        function drawGraph() {\n            // Clear SVG for the new graph\n            svg.selectAll(\"*\").remove();\n\n\n\n\n\n            // Create arrow definitions for links\n            svg.append(\"defs\").selectAll(\"marker\")\n                .data([\"end\"])\n                .enter().append(\"marker\")\n                .attr(\"id\", String)\n                .attr(\"viewBox\", \"0 -5 10 10\")\n                .attr(\"refX\", 15)\n                .attr(\"refY\", -1.5)\n                .attr(\"markerWidth\", 6)\n                .attr(\"markerHeight\", 6)\n                .attr(\"orient\", \"auto\")\n                .append(\"path\")\n                .attr(\"d\", \"M0,-5L10,0L0,5\")\n                .style(\"stroke\", \"#999\")\n                .style(\"opacity\", \"0.6\");\n\n            // JOIN new data with old elements.\n            let link = svg.selectAll(\"line\")\n                .data(links)\n                .join(\"line\")\n                .attr(\"marker-end\", \"url(#end)\")  // Add arrow to the end of line\n                .style(\"stroke\", d =&gt; d.lastActive === t ? 'red' : '#999')\n                .style(\"stroke-opacity\", 0.6)\n                .style(\"stroke-width\", d =&gt; Math.sqrt(d.value));\n\n            let node = svg.selectAll(\".node\")\n                .data(nodes)\n                .join(\"g\")\n                .attr(\"class\", \"node\");\n\n            const shapeSize = 20\n            node.each(function (d) {\n                if (d.type === 'event') {\n                    d3.select(this).append(\"rect\")\n                        .attr(\"width\", shapeSize) // Adjust the width and height as needed\n                        .attr(\"height\", shapeSize)\n                        .attr(\"fill\", \"orange\")\n                        .attr(\"opacity\", d =&gt; d.lastActive === t ? 1 : 0.4);\n                } else {\n                    d3.select(this).append(\"circle\")\n                        .attr(\"r\", shapeSize/2)\n                        .attr(\"fill\", \"cyan\")\n                        .attr(\"opacity\", d =&gt; d.lastActive === t ? 1 : 0.4);\n                }\n\n                d3.select(this).append(\"text\")\n                    .attr(\"dx\", 12)\n                    .attr(\"dy\", \".35em\")\n                    .text(d =&gt; d.id);\n            });\n\n\n\n            // UPDATE force simulation nodes and links\n            simulation.nodes(nodes);\n            simulation.force(\"link\").links(links);\n            // START/RESTART simulation\n            simulation.alpha(1).restart();\n\n            // Drag functions used for interactivity\n            function dragStarted(event, d) {\n                if (!event.active) simulation.alphaTarget(0.3).restart();\n                d.fx = d.x;\n                d.fy = d.y;\n            }\n\n            function dragged(event, d) {\n                d.fx = event.x;\n                d.fy = event.y;\n            }\n\n            function dragEnded(event, d) {\n                if (!event.active) simulation.alphaTarget(0);\n                d.fx = null;\n                d.fy = null;\n            }\n\n            node.call(d3.drag()\n                .on(\"start\", dragStarted)\n                .on(\"drag\", dragged)\n                .on(\"end\", dragEnded));\n\n\n            // // UPDATE node and link positions each tick\n            simulation.on(\"tick\", () =&gt; {\n                // Update node positions\n                node.select(\"circle\").attr(\"cx\", (d) =&gt; d.x)\n                    .attr(\"cy\", (d) =&gt; d.y);\n                node.select(\"rect\").attr(\"x\", (d) =&gt; d.x - shapeSize/2) // Subtract half the width\n                    .attr(\"y\", (d) =&gt; d.y - shapeSize/2);\n                node.select(\"text\").attr(\"x\", (d) =&gt; d.x)\n                    .attr(\"y\", (d) =&gt; d.y);\n\n                // Update link positions\n                link.attr(\"x1\", (d) =&gt; d.source.x)\n                    .attr(\"y1\", (d) =&gt; d.source.y)\n                    .attr(\"x2\", (d) =&gt; d.target.x)\n                    .attr(\"y2\", (d) =&gt; d.target.y);\n            });\n        }\n\n\n        function drawBoid(ctx, boid) {\n            const angle = Math.atan2(boid.dy, boid.dx);\n            ctx.translate(boid.x, boid.y);\n            ctx.rotate(angle);\n            ctx.translate(-boid.x, -boid.y);\n            ctx.fillStyle = boid.full ? \"gold\" : \"#558cf4\";\n            ctx.beginPath();\n            ctx.moveTo(boid.x, boid.y);\n            ctx.lineTo(boid.x - 15, boid.y + 5);\n            ctx.lineTo(boid.x - 15, boid.y - 5);\n            ctx.lineTo(boid.x, boid.y);\n            ctx.fill();\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n        }\n        function drawWorm(ctx, x, y) {\n            ctx.beginPath();\n            ctx.arc(x, y, 4, 2 * Math.PI, false);\n            ctx.fillStyle = 'pink';\n            ctx.fill();\n        }\n\n        let i = 0;\n        const currentBoidPositions = {}\n        const currentWormPositions = {}\n\n        function animationLoop() {\n            // Clear the canvas and redraw all the boids in their current positions\n            const ctx = document.getElementById(\"boids-canvas\").getContext(\"2d\");\n            ctx.clearRect(0, 0, 1000, 1000);\n            for (let boid_id of Object.keys(currentBoidPositions)) {\n                const { movement, full } = currentBoidPositions[boid_id]\n                drawBoid(ctx, {\n                    x: movement.position[0],\n                    y: movement.position[1],\n                    dx: movement.velocity[0],\n                    dy: movement.velocity[1],\n                    full\n                });\n            }\n            for (let worm_id of Object.keys(currentWormPositions)) {\n                const { worm_position: [x, y] } = currentWormPositions[worm_id]\n                drawWorm(ctx, x, y)\n            }\n\n        }\n        window.onload = () =&gt; {\n            // Schedule the main animation loop\n            const websocket = new WebSocket(\"ws://localhost:8765/\");\n\n            websocket.onmessage = ({ data }) =&gt; {\n                data = JSON.parse(data)\n                switch (data.event.event_type) {\n                    case \"WormEaten\":\n                        delete currentWormPositions[data.event.event_contents.worm_id]\n                        currentBoidPositions[data.event.event_contents.boid_id].full = true\n                        break\n                    case \"BoidMoved\":\n                        currentBoidPositions[data.event.event_contents.boid_id] = { ...data.event.event_contents, full: (currentBoidPositions[data.event.event_contents.boid_id] || {}).full }\n                        break\n                    case \"WormPopsHisHeadUp\":\n                        currentWormPositions[data.event.event_contents.worm_id] = data.event.event_contents\n                        break\n                }\n                updateGraph(data)\n                window.requestAnimationFrame(animationLoop);\n            };\n        };\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"examples/boids/#live-result","title":"Live Result","text":""},{"location":"examples/boids/#simulation-without-ws","title":"Simulation without WS","text":"<p>Instead of using websockets, we may take the approach of using the state of a process to collect history and create the visualisation using that after the simulation has ended.</p> <p>This has the disadvantage that memory could grow infinitely, but the advantage of performance!</p>"},{"location":"examples/boids/#define-simulation","title":"Define simulation","text":"<p>With out boost in performance we can add some more boids and more worms.</p> Simulation Setup Code <pre><code>    num_boids = 10 if use_websockets else 50\n    grid_size = (1000, 1000)\n    if use_websockets:\n        hades = HadesWS(\n            random_pomegranate_seed=\"Reynolds\", record_results=False, use_no_ack_cache=True, record_event_history=False\n        )\n    else:\n        hades = Hades(\n            random_pomegranate_seed=\"Reynolds\", record_results=False, use_no_ack_cache=True, record_event_history=False\n        )\n    hades.register_process(\n        process=PredefinedEventAdder(\n            predefined_events=[\n                BoidMoved(\n                    t=0,\n                    boid_id=i,\n                    movement=ImmutableMovement(position=(500 - i, 500 + i), velocity=(-1 - (0.1 * i), 1 + (0.1 * i))),\n                )\n                for i in range(num_boids)\n            ],\n            name=\"add boids\",\n        )\n    )\n    hades.register_process(\n        PredefinedEventAdder(\n            predefined_events=[\n                WormPopsHisHeadUp(\n                    worm_id=i,\n                    t=i,\n                    worm_position=(\n                        hades.random.randint(0, grid_size[0] - 1),\n                        hades.random.randint(0, grid_size[1] - 1),\n                    ),\n                )\n                for i in range(0, 1000, 50 if use_websockets else 5)\n            ],\n            name=\"worm spawner\",\n        )\n    )\n    hades.register_process(WormHider())\n    for i in range(num_boids):\n        hades.register_process(Boid(boid_identifier=i, grid_size=(1000, 1000)))\n\n    if not use_websockets:\n        movement_history = BoidMovementHistory(grid_size=(1000, 1000))\n        hades.register_process(movement_history)\n    await hades.run(until=run_till)\n\n    if not use_websockets:\n        with open(\"boids.html\", \"w\") as f:\n            f.write(movement_history.create_html_file())\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n\n    asyncio.run(run_sim(len(sys.argv) &gt; 1 and sys.argv[1] == \"websockets\"))\n</code></pre>"},{"location":"examples/boids/#history-collector-and-renderer","title":"History Collector and Renderer","text":"<p>Lets create a process to collect all the relevant events and expose a method to render the history as html. We now call this after the simulation ends.</p> BoidMovementHistory Code <pre><code>class BoidMovementHistory(Process):\n    def __init__(\n        self,\n        grid_size: tuple[int, int],\n        current_t: int = 0,\n    ) -&gt; None:\n        self._grid_size = grid_size\n        self._boid_history = [[]]\n        self._worms_alive = {}\n        self._worm_history = [[]]\n        self._fed_boids = set()\n        self._current_t = current_t\n        super().__init__()\n\n    async def notify(self, event: Event) -&gt; NotificationResponse:\n        match event:\n            case BoidMoved(t=t, boid_id=boid_id, movement=movement):\n                if t != self._current_t:\n                    self._worm_history.append(list(self._worms_alive.values()))\n                    self._boid_history.append([])\n                    self._current_t = t\n                self._boid_history[-1].append({\n                    \"boid_id\": boid_id,\n                    \"movement\": movement.dict(),\n                    \"full\": boid_id in self._fed_boids,\n                })\n\n                return NotificationResponse.ACK\n            case WormPopsHisHeadUp(t=t, worm_position=position, worm_id=worm_id):\n                self._worms_alive[worm_id] = position\n                return NotificationResponse.ACK\n\n            case WormEaten(worm_id=worm_id) | WormHid(worm_id=worm_id) as event:\n                if isinstance(event, WormEaten):\n                    self._fed_boids.add(event.boid_id)\n                try:\n                    del self._worms_alive[worm_id]\n                except KeyError:\n                    pass\n                return NotificationResponse.ACK\n\n        return NotificationResponse.NO_ACK\n\n    def create_html_file(self):\n        return f\"\"\"\n        &lt;head&gt;\n        &lt;title&gt;Boids&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n        &lt;canvas id=\"boids-canvas\" width=\"{self._grid_size[0]}\" height=\"{self._grid_size[1]}\"&gt;\n        &lt;script&gt;\n        const wormHistory = {json.dumps(self._worm_history)};\n        const boidHistory = {json.dumps(self._boid_history)};\n        function drawBoid(ctx, boid) {{\n            const angle = Math.atan2(boid.dy, boid.dx);\n            ctx.translate(boid.x, boid.y);\n            ctx.rotate(angle);\n            ctx.translate(-boid.x, -boid.y);\n            ctx.fillStyle = boid.full ? \"gold\" : \"#558cf4\";\n            ctx.beginPath();\n            ctx.moveTo(boid.x, boid.y);\n            ctx.lineTo(boid.x - 15, boid.y + 5);\n            ctx.lineTo(boid.x - 15, boid.y - 5);\n            ctx.lineTo(boid.x, boid.y);\n            ctx.fill();\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n        }}\n        function drawWorm(ctx, x, y) {{\n            ctx.beginPath();\n            ctx.arc(x, y, 4, 2 * Math.PI, false);\n            ctx.fillStyle = 'pink';\n            ctx.fill();\n        }}\n\n        let i = 0;\n\n        function animationLoop() {{\n            // Clear the canvas and redraw all the boids in their current positions\n            const ctx = document.getElementById(\"boids-canvas\").getContext(\"2d\");\n            ctx.clearRect(0, 0, {self._grid_size[0]}, {self._grid_size[1]});\n            for (let {{movement, boid_id, full}} of boidHistory[i]) {{\n                drawBoid(ctx, {{\n                    x: movement.position[0],\n                    y: movement.position[1],\n                    dx: movement.velocity[0],\n                    dy: movement.velocity[1],\n                    full \n                }});\n            }}\n            for (let [x, y] of wormHistory[i]) {{\n                drawWorm(ctx, x, y)\n            }}\n\n            i += 1;\n            if (i &gt;= boidHistory.length) {{\n                i = 0;\n            }}\n            // Schedule the next frame\n            window.requestAnimationFrame(animationLoop);\n\n        }}\n\n        window.onload = () =&gt; {{\n        // Schedule the main animation loop\n        window.requestAnimationFrame(animationLoop);\n        }};\n        &lt;/script&gt;\n        &lt;/body&gt;\n        \"\"\"\n</code></pre>"},{"location":"examples/boids/#the-rendered-result","title":"The Rendered Result","text":""},{"location":"examples/multi-agent-llm-storytelling/","title":"Multi-Agent LLM storytelling","text":""},{"location":"examples/multi-agent-llm-storytelling/#overview","title":"Overview","text":"<p>Let's try to use LLMs to simulate the story of the Odyssey being retold, but with a slight difference:</p> <p>Odysseus has a knowledge of and can use modern technology</p> <p>Using LLM API's and calling them asynchronously is a useful demonstration of the type of IO-Bound workloads which Hades is designed around. This will also illustrate some interesting features of the event loop.</p>"},{"location":"examples/multi-agent-llm-storytelling/#designing-the-processes","title":"Designing the processes","text":"<p>The processes and how they interact is the key to this simulation. The key idea is that we have a bit of a loop, which is enabled by the hades event loop:</p> <pre><code>flowchart TB\n    A[Homer records these and plans to synthesise them into a coherent story tomorrow]\n    C[Homer notifies the characters of the last day's story]\n    D[Odysseus]\n    E[Athena]\n    F[Zeus]\n    G[...]\n    H[OpenAI endpoint]\n\n    subgraph Characters act according to their character the last day's story\n        D\n        E\n        F\n        G\n    end\n\n    subgraph Homer\n        A\n        C\n    end\n\n    A --&gt;|time moves forward one day| C\n\n    C -.-&gt;|async| D\n    C -.-&gt;|async| E\n    C -.-&gt;|async| F\n    C -.-&gt;|async| G\n    D --&gt;|CharacterActed| A\n    E --&gt;|CharacterActed| A\n    F --&gt;|CharacterActed| A\n    G --&gt;|CharacterActed| A\n    D -.-&gt;|async| H\n    E -.-&gt;|async| H\n    F -.-&gt;|async| H\n    G -.-&gt;|async| H</code></pre>"},{"location":"examples/multi-agent-llm-storytelling/#implementation","title":"Implementation","text":""},{"location":"examples/multi-agent-llm-storytelling/#processes","title":"Processes","text":"<p>The core logic is within the processes </p> <pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom examples.multi_agent_llm_storytelling.models import GPTMessage\n\nfrom hades import Event, Process\nfrom hades.core.event import Event, SimulationEnded, SimulationStarted\nfrom hades.core.process import NotificationResponse\n\nfrom .events import CharacterActed, StoryUnfolded, SynthesisedEventsOfDay\nfrom .prompts import god_prompt, homer_prompt, odysseus_prompt\nfrom .utilities import plaintext_chat_response\n\n\nclass Homer(Process):\n    def __init__(self) -&gt; None:\n        self._story_of_day = {}\n        self._events_of_day = {}\n        super().__init__()\n\n    @property\n    def story_so_far(self):\n        story_so_far = \"\"\n        for story_day, story in self._story_of_day.items():\n            story_so_far += f\"\\nDay {story_day}: {story}\\n\"\n        return story_so_far\n\n    async def notify(self, event: Event):\n        match event:\n            case SynthesisedEventsOfDay(day=day, t=t):\n                events_of_day = \"\\n\".join([str(e) for e in self._events_of_day[day]])\n                story_of_day = await plaintext_chat_response(\n                    messages=[\n                        GPTMessage(\n                            role=GPTMessageRole.SYSTEM,\n                            content=homer_prompt.format(story_so_far=self.story_so_far[-2000:], day=day),\n                        ),\n                        GPTMessage(\n                            role=GPTMessageRole.USER,\n                            content=f\"Events ```{events_of_day}```\",\n                        ),\n                    ]\n                )\n                self.add_event(StoryUnfolded(t=t, chapter=story_of_day))\n                self._story_of_day[day] = story_of_day\n                print(f\"Day {day}: {story_of_day}\")\n                return NotificationResponse.ACK\n            case CharacterActed() as e:\n                # collect all the events of the day to synthesise the next day\n                try:\n                    self._events_of_day[e.t].append(e)\n                except KeyError:\n                    self._events_of_day[e.t] = [e]\n                    self.add_event(SynthesisedEventsOfDay(t=e.t + 1, day=e.t))\n                return NotificationResponse.ACK\n            case SimulationEnded():\n                print(self.story_so_far)\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n\n\nclass Odysseus(Process):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._name = \"Odysseus\"\n        self._action_history = []\n\n    async def notify(self, event: Event):\n        match event:\n            case SimulationStarted(t=t):\n                self.add_event(\n                    CharacterActed(\n                        t=t,\n                        character_name=self._name,\n                        action=(\n                            \"Odyssues crys out in frustration at being stuck in Troy because Poseidon won't allow him\"\n                            \" home\"\n                        ),\n                    )\n                )\n            case StoryUnfolded() as e:\n                recent_affairs = \"\\n\".join(self._action_history[-5:])\n                response = await plaintext_chat_response(\n                    messages=[\n                        GPTMessage(\n                            role=GPTMessageRole.SYSTEM,\n                            content=odysseus_prompt.format(recent_affairs=recent_affairs, day=e.t),\n                        ),\n                        GPTMessage(\n                            role=GPTMessageRole.USER,\n                            content=str(e),\n                        ),\n                    ]\n                )\n                self._action_history.append(str(e))\n                if response:\n                    event = CharacterActed(t=e.t, action=response, character_name=self._name)\n                    self.add_event(event)\n                    self._action_history.append(str(response))\n\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n\n\nclass GreekGod(Process):\n    def __init__(self, name: str) -&gt; None:\n        self._name = name\n        self._history = []\n        self._motives = None\n        super().__init__()\n\n    @property\n    def history_message(self):\n        if self._history:\n            return \" You have the following recent history: \" + \"\\n\".join(self._history[-5:])\n        else:\n            return \"\"\n\n    async def notify(self, event: Event):\n        match event:\n            case SimulationStarted():\n                motives = await plaintext_chat_response(\n                    messages=[\n                        GPTMessage(\n                            role=GPTMessageRole.USER,\n                            content=f\"\"\"\"\n                        Describe the core motives of {self._name} at the start of the Odyssey in less than 200 words.\"\"\",\n                        )\n                    ]\n                )\n                print(f\"{self._name} Motivations:\\n{motives}\")\n                self._motives = motives\n                return NotificationResponse.ACK\n            case StoryUnfolded() as e:\n                response = await plaintext_chat_response(\n                    messages=[\n                        GPTMessage(\n                            role=GPTMessageRole.SYSTEM,\n                            content=god_prompt.format(\n                                god_name=self._name, motives=self._motives, day=e.t, history=self.history_message\n                            ),\n                        ),\n                        GPTMessage(\n                            role=GPTMessageRole.USER,\n                            content=e.chapter,\n                        ),\n                    ]\n                )\n                self._history.append(str(e))\n                if response:\n                    event = CharacterActed(t=e.t, action=response, character_name=self._name)\n                    self.add_event(event)\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"examples/multi-agent-llm-storytelling/#additional-code","title":"Additional Code","text":"Event Definitions <pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom pydantic import BaseModel, ConfigDict\n\nfrom hades import Event\n\n\nclass CharacterAction(BaseModel):\n    location: str\n    action_description: str\n    model_config = ConfigDict(frozen=True)\n\n\nclass StoryUnfolded(Event):\n    chapter: str\n\n    def __str__(self) -&gt; str:\n        return f\"Day {self.t}: {self.chapter}\"\n\n\nclass CharacterActed(Event):\n    action: str\n    character_name: str\n\n    def __str__(self) -&gt; str:\n        return f\"\"\"\n        Character: {self.character_name}\n        Day: {self.t}\n        Action: {self.action}\n        \"\"\"\n\n\nclass SynthesisedEventsOfDay(Event):\n    day: int\n</code></pre> LLM Prompts <pre><code>    # Copyright 2023 Brit Group Services Ltd.\n    #\n    # Licensed under the Apache License, Version 2.0 (the \"License\");\n    # you may not use this file except in compliance with the License.\n    # You may obtain a copy of the License at\n    #\n    #      http://www.apache.org/licenses/LICENSE-2.0\n    #\n    # Unless required by applicable law or agreed to in writing, software\n    # distributed under the License is distributed on an \"AS IS\" BASIS,\n    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    # See the License for the specific language governing permissions and\n    # limitations under the License.\n\n    homer_prompt = \"\"\"\n    You are the writer Homer chronicling the adventures of a greek hero Odysseus.\n\n    Here is your story so far.\n    ---\n    {story_so_far}\n    ---\n    You will be informed by the user of the events of the current day.\n\n    You will synthesise these events into a cohesive narrative in the style of Homer to form the story of day {day}.\n\n    The story should never end. \n\n    Remove inconsistent elements. \n\n    Use under 200 words.\n\n    Example\n    User: Events: ```\n    Character: Odysseus\n    Day: 0\n    Action: Odysseus is stuck on troy because Poseidon won't allow him home\n    ```\n    Assistant:  As the morning sun rose on Troy, the great hero Odysseus sat frustrated and stuck. He longed to return to his home, his wife and his son, but Poseidon had cursed him, preventing his journey home.\n    Odysseus had tried every trick in his book to appease the sea god, but to no avail. And so he sat, day after day, trying to find any solution to his problem.\n    \"\"\"\n\n    odysseus_prompt = \"\"\"\n    You are the hero Odysseus.\n    You have the history and motivations of Odysseus at the start of the Odyssey but you also have\n    an understanding of modern science and technology which you use creatively to your advantage\n    plus the following events.\n    ---\n    {recent_affairs}\n    ---\n    The user will inform you the latest chapter in your tale and you must decide how to react to it \n    and come up with an action, given the story so far and your current goals and motivations. \n\n    Describe what action you will take today (Day {day}).\n\n    If you use modern technology or science specify exactly what and how.\n\n    Use under 200 words.\n    \"\"\"\n\n    god_prompt = \"\"\"\"\n    You are the greek god {god_name}. You have the history and motivations of {god_name} at the \n    start of the Odyssey:\n    {motives} \n    plus the following recent history of your own actions and those of Odysseus\n    ---\n    {history}\n    ---\n    The user will tell you the latest chapter of the story. Describe what action you will take today (Day {day}).\n\n    Use under 200 words.\n    \"\"\"\n</code></pre> Utilities <pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport asyncio\nimport os\nfrom dataclasses import asdict\n\nimport openai\nfrom examples.multi_agent_llm_storytelling.models import GPTMessage, GPTModelVersion\nfrom openai.error import APIError, RateLimitError, Timeout\n\nAPI_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n\nasync def plaintext_chat_response(messages: list[GPTMessage], tries=7):\n    try:\n        plaintext_response = await openai.ChatCompletion.acreate(\n            api_key=API_KEY, model=GPTModelVersion.GPT_3_5, messages=[asdict(message) for message in messages]\n        )\n        return plaintext_response.choices[0].message.content\n    except (RateLimitError, APIError, Timeout) as e:\n        if tries == 0:\n            raise e\n        await asyncio.sleep((8 - tries) ** 2)\n        return await plaintext_chat_response(messages, tries - 1)\n</code></pre>"},{"location":"examples/multi-agent-llm-storytelling/#putting-it-all-together","title":"Putting it all together","text":"<pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport asyncio\n\nfrom examples.multi_agent_llm_storytelling.processes import GreekGod, Homer, Odysseus\n\nfrom hades import Hades\n\n\nasync def simulate():\n    world = Hades(batch_event_notification_timeout=20 * 60)\n    world.register_process(Odysseus())\n    homer = Homer()\n    world.register_process(homer)\n    for name in (\"Athena\", \"Zeus\", \"Poseidon\", \"Helios\"):\n        world.register_process(GreekGod(name=name))\n    await world.run(until=10)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(simulate())\n</code></pre>"},{"location":"examples/multi-agent-llm-storytelling/#the-resulting-story","title":"The resulting story","text":"<p>Day 0: As the morning sun rose on Troy, the great hero Odysseus sat on the shore, tears streaming down his face. He cried out in frustration, feeling helpless and powerless against the wrath of Poseidon. Every trick he had up his sleeve had failed to sway the city's underwater ruler. Now, Odysseus was confined to the city where he had fought so heroically. </p> <p>His heart ached to return to his homeland, to his loyal wife Penelope, and his beloved son Telemachus. But it seemed that Poseidon had other plans. Despite his weariness, Odysseus remained determined to find a way home. He began strategizing, hatching a plan that would enable him to escape Troy's grip and overcome the mighty Poseidon. Until then, he would remain vigilant, biding his time until the right opportunity presented itself. And so the hero waited, his heart heavy with longing, but his spirit still burning bright.</p> <p>Day 1: As the sun rose on the second day, Odysseus remained determined to find a way to overcome the might of the sea god, with the support of Athena as his only ally. He continued with his daily training regimen with the soldiers in Troy, keeping his body and mind sharp. During his free time, he spent his days researching and trying to understand the behavior of Poseidon by gathering information from the local fishermen and sailors. He also studied modern technology that he could use to beat the sea god and return home.</p> <p>Meanwhile, Helios, the lord Sun, sent a fiery symbol to the skies, warning Odysseus of the impending danger that he would face if he did not atone for his misdeeds. Though not unleashing his full wrath, Helios observed Odysseus from a distance, waiting and watching for his next move.</p> <p>Zeus continued to keep a close eye on the situation, subtly guiding the events to ensure that Odysseus would be able to complete his journey home safely. Despite not being able to intervene, Zeus reassured Odysseus that he had his support. </p> <p>In the midst of this ongoing struggle, Poseidon's anger flared up again, and he summoned his most powerful sea creatures to create a massive storm, which bashed against the shores of Troy. However, Poseidon soon realized that his sense of satisfaction was temporary, and he retreated to his underwater palace, wondering if his grudge against Odysseus was worth all the destruction and chaos he had caused.</p> <p>As the balance of power shifted among the gods, Odysseus remained determined to find a way home. With tenacity, he spent each day gathering intelligence and training, all the while praying for the support of the gods and his safe return home to his family.</p> <p>Day 2: As the third day dawned, Odysseus remained focused on his goal of returning home, using all his knowledge and resources to overcome the challenges that lay ahead. He was heartened by the support of Athena and Zeus, who had provided him with guidance and protection, and the intervention of Helios, who had calmed the storm and allowed him to slip away from Troy unnoticed.</p> <p>As Odysseus sailed along the coastline, he kept a close eye on the skies, hoping for any signs from the gods that might aid him in his journey. Meanwhile, he continued to use his knowledge of modern science and technology to create diversions and evade the wrath of Poseidon.</p> <p>Poseidon, still seething with anger, decided to take a more direct approach to stop Odysseus. He summoned his most powerful sea creatures and unleashed a massive wave that threatened to overturn Odysseus' boat. But to his surprise, the sea nymph that Zeus had directed Odysseus to seek out appeared beside him, calming the waters and protecting him from Poseidon's fury.</p> <p>With the sea nymph's help, Odysseus continued his journey with renewed strength and determination. He knew that there were still many obstacles ahead, but he was resolute in his belief that he would overcome them all and return home to his beloved family.</p> <p>Day 3: On the third day of his journey, Odysseus sought out alliances that could aid him in his quest home. He remembered the sea nymph who had helped him before and realized that having allies like her was crucial to his success. He also continued to use his technological knowledge to stay ahead of Poseidon's wrath, utilizing his drone and sonar to navigate the waters safely.</p> <p>Meanwhile, Helios kept a watchful eye on the situation, withholding his full wrath for now, but sending a fiery symbol to the skies as a warning to Odysseus. Athena continued to aid Odysseus when necessary, offering counsel and support, and mediating disputes in the mortal world with her strategic vision.</p> <p>Zeus, pleased with Odysseus's resourcefulness, sent Hermes to guide him and provide him with essential information about his journey. Hermes appeared to Odysseus as a friendly stranger, teaching him the secrets of the winds and currents, and providing him with a magical talisman that would protect him from Poseidon's wrath.</p> <p>Poseidon's anger flared up again on this day, as he summoned his most fearsome sea creatures and unleashed a massive storm to halt Odysseus's progress. But even he was no match for the combined power of Athena, Helios, and the sea nymph, who calmed the storm and tamed Poseidon's sea monsters, sparing Odysseus and his crew from certain death.</p> <p>Frustrated and defeated once again, Poseidon retreated to his underwater palace, vowing to continue to make Odysseus's journey home as difficult as possible. But Odysseus remained determined, relying on his resourcefulness, intelligence, and alliances to guide him safely back to his beloved family.</p> <p>Day 4: On the fourth day of his journey, Odysseus reflected on the valuable allies who had aided him thus far. He knew that he needed all the help he could get to overcome the obstacles before him and decided to actively seek out new potential allies, specifically among the sea creatures who could guide him through the treacherous waters.</p> <p>Using his underwater drone and sonar, he searched for groups of dolphins and schools of fish who could offer him insight into the sea's patterns and hazards. He also used his knowledge of technology to create a mapping system of the waters he'd traveled so far, marking potential dangers and hidden currents to navigate safely.</p> <p>Odysseus reached out to Hermes, hoping for further guidance and intel on potential allies and hazards ahead. The sea nymph who had aided him before granted him her blessing, promising to protect him from Poseidon and guide him through any future obstacles.</p> <p>However, Poseidon remained powerful and determined to thwart Odysseus's journey home, setting up a blockade to prevent him from reaching his beloved family. Odysseus knew he needed to find a way to overcome this obstacle and consulted with Athena, who advised him to seek out the goddess of the winds, Aeolus.</p> <p>Odysseus encountered a group of pirates who attempted to steal his supplies but used his cunning to escape. He finally reached Aeolus's island, where she offered her powers over the winds to create a path through Poseidon's blockade. Along the way, he learned that one of his crew members was secretly working with Poseidon, whom Zeus had warned him of.</p> <p>Undeterred, Odysseus remained vigilant and determined to overcome any threat to his journey home. With the support of his allies and his own resourcefulness, he continued to navigate the treacherous waters, one step closer to the reunion he longed for.</p> <p>Day 5: As the sun rose on the fifth day of Odysseus's journey, Helios, Zeus, Poseidon and Athena all monitored the hero's progress with interest.</p> <p>Odysseus, having learned from his experiences with the pirates, developed a strategic plan to protect his crew and supplies. He stored essential items in a hidden compartment and created a surveillance system to monitor the crew's behavior. Drawing on his modern knowledge, he scouted for new allies with the help of his underwater drone and sonar.</p> <p>Zeus and Athena lauded him for his resourcefulness, as Poseidon still boiled with rage and plotted to take Odysseus down. Meanwhile, Helios watched, warning Odysseus of the dangers ahead and subtly signaling Poseidon not to interfere further.</p> <p>As Odysseus continued his journey, he navigated through Poseidon's blockade, making his way past the threats with the help of Athena, the sea nymph, and Aeolus. Along the way, he even managed to outsmart a crew member who had been working secretly with Poseidon. </p> <p>With Athena's guidance, Odysseus managed to trick the Sirens and gain their navigational knowledge while saving a ship's crew from their deadly songs. With renewed vigor and confidence, he accelerated his journey with his remaining allies, ready to face Poseidon and whatever obstacles lay ahead.</p> <p>As the gods watched from above, they hoped to guide Odysseus safely home, recognizing his determination and resourcefulness in the face of adversity. Poseidon still seethed, but Helios held back his wrath while Zeus and Athena maintained balance and justice. The journey continued, and no one knew what lay ahead for the great hero.</p> <p>Day 6: As the sixth day of his journey progressed, Odysseus found himself facing one of his greatest challenges yet. Poseidon, still seeking revenge for the death of his son Polyphemus, sent an army of sea monsters to attack Odysseus and his crew. Thanks to his resourcefulness and modern knowledge, Odysseus was able to fend off the beasts with the help of his allies, including Athena and Helios.</p> <p>As the battle raged on for hours, Odysseus rallied his crew, using his knowledge of modern warfare to outsmart the sea monsters. His crew was in a state of panic, but Odysseus made sure to keep them together and use his surveillance system to anticipate the monsters' movements.</p> <p>Poseidon was furious, but Helios held back his wrath while Zeus and Athena provided strategic guidance to Odysseus. In the end, Odysseus emerged victorious, having defeated the sea monsters and continued on his journey with renewed determination.</p> <p>As the sunset, Zeus sent down a message to Odysseus, letting him know that he would have a new ally for the day - a falcon who would guide him towards safety. With the falcon leading the way, Odysseus and his crew sailed through dangerous waters and encountered a group of sea turtles who offered their swimming and navigation knowledge.</p> <p>As they continued on, Poseidon attempted to interfere with Odysseus' efforts once again, but was thwarted by the combined power of the gods and Odysseus' resourcefulness. The hero knew that while many challenges lay ahead, he was ready to face whatever came his way with his vigilance, technological resources and strategic planning.</p> <p>Day 7: On day 7, Odysseus and his crew were emboldened by their recent victories and newfound alliances. With the guidance of Athena, Odysseus expertly navigated the treacherous strait guarded by a six-headed monster and emerged victorious. Helios warned Odysseus of an approaching storm, but with his modern technology, Odysseus was able to deploy an anchor and keep the ship steady.</p> <p>Zeus sent the falcon to lead them to a safe and uncharted island where they found resources, friendly mermaids and guidance on underwater currents. Despite Poseidon's wrath, Odysseus remained vigilant and strategic in his approach to each challenge, using his mapping system and sonar to chart the waters ahead and identify allies.</p> <p>Zeus informed Odysseus of a stop in Circe's city, where they found the people under Circe's spell. Odysseyus broke the spell and convinced the people to help him persuade Circe for knowledge.</p> <p>They encountered friendly dolphins who guided them through the waters, and with the help of Athena and his drone, Odysseus navigated through a dangerous whirlpool. The gods watched with admiration, impressed by Odysseus's resourcefulness and fortitude. Although Poseidon remains furious, Odysseus remained ready to face any challenge and make his way back home to his loved ones, with the support of the gods and his allies.</p> <p>Day 8: On Day 8 of Odysseus' journey, he reflected on the challenges he had faced and the resources and allies he had gathered thus far. With his crew and Athena's guidance, he planned a proactive strategy to approach Circe's city undetected and convince her to provide him with the knowledge he needed to continue his journey.</p> <p>With his modern technology and strategic planning, Odysseus created a decoy ship to distract any guards and mapped out the city's surroundings using his sonar and mapping system. With Athena's support, he crafted a plan to communicate with Circe and gain her trust.</p> <p>As they sailed on, Poseidon continued to hinder their progress, but Odysseus and his allies remained vigilant and prepared for the unexpected. With Helios warning of an attack from Poseidon's sea monsters, Odysseus was able to protect his crew and fend off the threats.</p> <p>Meanwhile, on a remote island, Odysseus and his crew discovered powerful artifacts containing valuable knowledge about the history of the gods and their powers. With Athena's guidance, they deciphered the inscriptions and gained new allies.</p> <p>As the day drew to a close, rescue ships arrived to aid Odysseus and his crew. They continued their journey home with newfound knowledge and allies. As they approached their toughest challenge yet, the confrontation with the Cyclops, Athena advised caution and reliance on allies. With Zeus's guidance, Odysseus prepared for the final obstacle before making his way home to his beloved family.</p> <p>Day 9: As the sun rose on the ninth day of his journey, the great hero Odysseus prepared to confront the mighty Cyclops. With the guidance of the wise goddess Athena, he relied on his modern knowledge and strategic planning to defeat the giant.</p> <p>Using his advanced surveillance system and strategic vision, Odysseus and his crew devised a plan to blind the beast with a new invention - laser light - and attack with their harpoons and nets. His allies, the sea turtles and friendly dolphins, scouted out the best approach and identified potential threats. Helios warned of Poseidon's wrath, but Odysseus remained vigilant and brave.</p> <p>With the help of the sea nymph and Athena, they blinded the Cyclops and escaped. Despite Poseidon's fury at the loss of his son Polyphemus, Odysseus continued his journey with the support of Zeus and Athena.</p> <p>But their path was not yet clear - further challenges awaited. However, with his resourcefulness and strategic planning, Odysseus remained steadfast on his mission to return home to his beloved family and reclaim his rightful place as king. With renewed confidence and determination, they continued on their journey, relying on their allies and modern technology to overcome any obstacle in their path.</p>"},{"location":"examples/simple-simulation/","title":"A Simple Simulation","text":"<p>Here we are going to build a simple simulation where we simulate Zeus sending lightning bolts and Poseidon creating storms, both potentially affecting the life of Odysseus</p>"},{"location":"examples/simple-simulation/#imports","title":"Imports","text":"<pre><code>import asyncio\nfrom enum import Enum\n\nfrom hades import Event, Hades, NotificationResponse, Process, RandomProcess, SimulationStarted\n</code></pre>"},{"location":"examples/simple-simulation/#defining-our-events","title":"Defining our Events","text":"<p>Let's begin by defining some events we want to exist. Lets have one for Zeus throwing lightning at a target, one for Poseidon causing a storm near a target, one for Athena Intervening to help someone, and one for Odysseus dying.</p> <pre><code>class LightningBoltThrown(Event):\n    target_id: str\n\n\nclass StormCreated(Event):\n    target_id: str\n\n\nclass OdysseusDied(Event):\n    pass\n\n\nclass AthenaIntervened(Event):\n    target_id: str\n</code></pre>"},{"location":"examples/simple-simulation/#adding-the-god-processes","title":"Adding the God Processes","text":"<p>Okay now we have our events we need some processes to actually do stuff with them. Let's start by defining some simple ones for Zeus and Poseidon to simply use their powers on Odysseus at intervals. To do this they can react to the builtin <code>SimulationStarted</code> event.</p> <pre><code>class Zeus(Process):\n    async def notify(self, event: Event):\n        match event:\n            case SimulationStarted(t=t):\n                for i in range(0, 100, 25):\n                    self.add_event(LightningBoltThrown(t=t + i + 2, target_id=\"Odysseus\"))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n\n\nclass Poseidon(Process):\n    async def notify(self, event: Event):\n        match event:\n            case SimulationStarted(t=t):\n                for i in range(0, 100, 5):\n                    self.add_event(StormCreated(t=t + i + 2, target_id=\"Odysseus\"))\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"examples/simple-simulation/#adding-odysseus-process","title":"Adding Odysseus' Process","text":"<p>Now lets do this for our hero Odysseus. We want to make it so that Odysseus will take a random amount of damage when he is the target of a <code>LightningBoltThrown</code> or <code>StormCreated</code>, if his health points are depleted we will set his state to deceased using an Enum.</p> <pre><code>class HeroLifeCycleStage(Enum):\n    SAFE = 1\n    IN_DANGER = 2\n    DECEASED = 3\n</code></pre> <p>Finally if <code>AthenaIntervened</code> his health will be restored and he will be <code>SAFE</code>.</p> <pre><code>class Odysseus(RandomProcess):\n    def __init__(self, seed):\n        super().__init__(seed)\n        self.status = HeroLifeCycleStage.SAFE\n        self._health = 100\n\n    @property\n    def instance_identifier(self) -&gt; str:\n        return \"Odysseus\"\n\n    def _handle_peril(self, t: int, max_damage: int, source: str):\n        self.status = HeroLifeCycleStage.IN_DANGER\n        print(f\"odysseus is in danger from {source}!\")\n        lost_hp = round(self.random.random() * max_damage)\n        self._health = max(self._health - lost_hp, 0)\n        print(f\"odysseus' health dropped to {self._health}\")\n        if self._health == 0:\n            print(\"odysseus died\")\n            self.status = HeroLifeCycleStage.DECEASED\n            self.add_event(OdysseusDied(t=t))\n\n    async def notify(self, event: Event):\n        match event:\n            case LightningBoltThrown(t=t, target_id=target_id):\n                if self.status == HeroLifeCycleStage.DECEASED:\n                    return NotificationResponse.ACK_BUT_IGNORED\n                self._handle_peril(t, 90, \"Zeus' lightning bolt\")\n                return NotificationResponse.ACK\n            case StormCreated(t=t, target_id=target_id):\n                if target_id != self.instance_identifier or self.status == HeroLifeCycleStage.DECEASED:\n                    return NotificationResponse.ACK_BUT_IGNORED\n                self._handle_peril(t, 50, \"Poseidon's storm\")\n                return NotificationResponse.ACK\n            case AthenaIntervened(t=t, target_id=target_id):\n                print(\"but athena intervened saving and healing odysseus to 100\")\n                self._health = 100\n                self.status = HeroLifeCycleStage.SAFE\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"examples/simple-simulation/#adding-athenas-process","title":"Adding Athena's Process","text":"<p>Last lets add the crucial Athena process. Let's have her do two things. Firstly, similar to <code>Poseidon</code> and <code>Zeus</code> lets make her have some predefined time to act. At <code>t=3</code> say where she will, no matter what, intervene.</p> <p>Secondly, whenever <code>OddyseusDied</code> she will have a <code>50%</code> chance of intervening. Note that this will happen on the same timestep! See API Reference &gt; Hades for more on how this works!</p> <pre><code>class GoddessAthena(RandomProcess):\n    async def notify(self, event: Event):\n        match event:\n            case SimulationStarted(t=t):\n                self.add_event(AthenaIntervened(t=t + 3, target_id=\"Odysseus\"))\n                return NotificationResponse.ACK\n            case OdysseusDied(t=t):\n                if self.random.random() &gt; 0.5:\n                    self.add_event(AthenaIntervened(t=t, target_id=\"Odysseus\"))\n                else:\n                    print(\"athena was too late to save odysseus\")\n                return NotificationResponse.ACK\n        return NotificationResponse.NO_ACK\n</code></pre>"},{"location":"examples/simple-simulation/#putting-it-all-together","title":"Putting it all together","text":"<p>Finally we want to actually run these processes together</p> <pre><code>async def odyssey():\n    world = Hades()\n    world.register_process(Zeus())\n    world.register_process(Poseidon())\n    world.register_process(Odysseus(\"pomegranate\"))\n    world.register_process(GoddessAthena(\"pomegranate\"))\n\n    await world.run()\n</code></pre> <p>Note how we instantiate <code>Odysseus</code> and <code>Athena</code> with a random seed to ensure every time we run this we get the same result. They inherit from <code>RandomProcess</code> to do this.</p> <p>We could also vary this over multiple runs to have an idea of how long `Odysseus' adventure lasts on average.</p>"},{"location":"examples/simple-simulation/#simulation-output","title":"Simulation Output","text":"<p>Running the above we get the following output: <pre><code>odysseus is in danger from Zeus' lightning bolt!\nodysseus' health dropped to 77\nodysseus is in danger from Poseidon's storm!\nodysseus' health dropped to 63\nbut athena intervened saving and healing odysseus to 100\nodysseus is in danger from Poseidon's storm!\nodysseus' health dropped to 78\nodysseus is in danger from Poseidon's storm!\nodysseus' health dropped to 65\nodysseus is in danger from Poseidon's storm!\nodysseus' health dropped to 42\nodysseus is in danger from Poseidon's storm!\nodysseus' health dropped to 42\nodysseus is in danger from Zeus' lightning bolt!\nodysseus' health dropped to 30\nodysseus is in danger from Poseidon's storm!\nodysseus' health dropped to 0\nodysseus died\nathena was too late to save odysseus\n</code></pre></p>"},{"location":"guides/performance/","title":"Improving Performance","text":"<p>With a lot of simulations, performance will be a core concern. Hades is built with performance in mind but with a primary focus on IO-bound workloads rather than CPU-bound ones.</p> <p>Hades runs on a single thread, but using <code>asyncio</code>, event notifications happen concurrently.</p> <p>This means that depending on what the <code>notify()</code> method does on the processes within the simulation, it may be far quicker than a multi-processing approach using all of your CPU cores, or a bit slower than running synchronously.</p> <p>Let's take two examples</p>"},{"location":"guides/performance/#cpu-bound","title":"CPU Bound","text":"<p>As you might notice in the following example, none of the methods called when a <code>Boid</code> process (from the boids example) reacts to a <code>BoidMoved</code> event, are <code>async</code> flavoured.</p> <pre><code>            case BoidMoved(t=t, boid_id=boid_id, movement=movement):\n                self._other_boid_positions[boid_id] = movement\n                if boid_id == self._boid_identifier:\n                    # We will only get this once per time step so its our opportunity to move!\n                    if not self._movement:\n                        self._movement = BoidMovement(**movement.dict())\n                    self._move_to_target_worm()\n                    self._cohere()\n                    self._ensure_seperation()\n                    self._align()\n                    self._slow_down()\n                    self._movement.move(grid_size=self._grid_size)\n                    if self._target_worm:\n                        worm_id, worm_position = self._target_worm\n                        if self._movement.distance(worm_position) &lt; self._worm_eat_distance:\n                            _logger.info(f\"worm {worm_id} eaten by boid {self._boid_identifier}\")\n                            self.add_event(\n                                WormEaten(\n                                    t=t + 1,\n                                    worm_id=worm_id,\n                                    boid_id=self._boid_identifier,\n                                )\n                            )\n                    self.add_event(\n                        BoidMoved(t=t + 1, boid_id=boid_id, movement=ImmutableMovement(**self._movement.dict()))\n                    )\n                return NotificationResponse.ACK\n</code></pre> <p>This means that we will get no speed up from running them concurrently in an <code>asyncio.gather</code>. An approach utilising multiple CPU cores or at least not slowing stuff down by creating coroutines etc may be faster here. </p> <p>However, CPU bound tasks may still benefit from the Hades approach. After all there is a limit to the number of cores likely to be present on a physical machine vs. on any machine over the network!</p> <p>We could, for example, implement an API endpoint which takes the <code>BoidMoved</code> event over HTTP and does all the processing to return another event. We could then scale to millions of Boids being handled in a reasonable time frame!</p>"},{"location":"guides/performance/#io-bound","title":"IO Bound","text":"<p>IO Bound tasks are Hades' bread and butter. When there are multiple IO-bound things being done through <code>asyncio</code> by separate processes during a timestep, or even by the same process, but in response to a different event, they will all be done concurrently before moving to the next timestep.</p> <p>Note</p> <p>Concurrent handling of events within the same process does have some things to be careful of (see process)</p> <pre><code>        else:\n            return \"\"\n\n    async def notify(self, event: Event):\n        match event:\n            case SimulationStarted():\n                motives = await plaintext_chat_response(\n                    messages=[\n                        GPTMessage(\n                            role=GPTMessageRole.USER,\n                            content=f\"\"\"\"\n                        Describe the core motives of {self._name} at the start of the Odyssey in less than 200 words.\"\"\",\n                        )\n                    ]\n                )\n                print(f\"{self._name} Motivations:\\n{motives}\")\n                self._motives = motives\n                return NotificationResponse.ACK\n            case StoryUnfolded() as e:\n                response = await plaintext_chat_response(\n                    messages=[\n                        GPTMessage(\n                            role=GPTMessageRole.SYSTEM,\n                            content=god_prompt.format(\n                                god_name=self._name, motives=self._motives, day=e.t, history=self.history_message\n                            ),\n                        ),\n                        GPTMessage(\n                            role=GPTMessageRole.USER,\n                            content=e.chapter,\n                        ),\n                    ]\n                )\n                self._history.append(str(e))\n                if response:\n                    event = CharacterActed(t=e.t, action=response, character_name=self._name)\n</code></pre>"},{"location":"guides/performance/#optimising-for-performance","title":"Optimising for Performance","text":"<p>Apart from ensuring you are taking advantage of <code>async</code> implementations for IO bound tasks within processes (e.g. <code>httpx</code> instead of <code>requests</code>), there are a number of other performance optimisations you can make in terms of configuring <code>Hades</code>.</p> <p>These arguments are detailed in Hades, and mostly involve removing some non-essential functionality to give better performance.</p> <p>These are used to speed things up in the boids example. <pre><code>        )\n    hades.register_process(\n        process=PredefinedEventAdder(\n</code></pre></p>"},{"location":"guides/visualisation/","title":"Visualisation","text":"<p>Hades largely leaves visualisation up to the user. However it does provide some batteries for a few different options.</p> <ol> <li>Visualising using recorded events and event results from the <code>Hades</code> instance (useful for building graphs of events and simulation level visualisation).</li> <li>Visualising using the state of a process (useful for <code>matplotlib</code> / notebook rendering of individual processes).</li> <li>Visualising live using a process or a subclass of <code>Hades</code> like <code>HadesWS</code>. (useful for live rendering of long running simulations)</li> </ol>"},{"location":"guides/visualisation/#visualising-using-hades-recorded-events","title":"Visualising using Hades recorded events","text":"<p>Hades can record events and their results. See <code>hades.event_results</code> and <code>hades.event_history</code>.</p> <p>This can be used to reconstruct a simulation as it happened or visualise the structure of the simulation itself based on responses.</p> Tests demonstrating networkx DiGraph creation and mermaid rendering based on recorded events <pre><code># Copyright 2023 Brit Group Services Ltd.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pytest\n\nfrom hades import Hades\nfrom hades.time import QuarterStartScheduler, YearStartScheduler\nfrom hades.visualisation.networkx import to_digraph, write_mermaid\n\n\n@pytest.fixture\nasync def simple_sim():\n    hades = Hades()\n    hades.register_process(YearStartScheduler(start_year=2021))\n    hades.register_process(QuarterStartScheduler())\n\n    await hades.run()\n    return hades\n\n\nasync def test_hades_process_events_to_digraph_for_simple_sim(simple_sim):\n    digraph = to_digraph(simple_sim)\n    expected_nodes = (\n        \"HadesInternalProcess - 7970269937446031133269215595648805179\",\n        \"YearStartScheduler - 332231294394531790607923355838092946842\",\n        \"QuarterStartScheduler - 7836064115094481643618470001379502846\",\n    )\n    expected_edges = (\n        (\n            \"HadesInternalProcess - 7970269937446031133269215595648805179\",\n            \"YearStartScheduler - 332231294394531790607923355838092946842\",\n            0,\n        ),\n        (\n            \"HadesInternalProcess - 7970269937446031133269215595648805179\",\n            \"YearStartScheduler - 332231294394531790607923355838092946842\",\n            1,\n        ),\n        (\n            \"YearStartScheduler - 332231294394531790607923355838092946842\",\n            \"QuarterStartScheduler - 7836064115094481643618470001379502846\",\n            0,\n        ),\n    )\n    assert tuple(digraph.nodes) == expected_nodes\n    assert tuple(digraph.edges) == expected_edges\n\n\ndef test_digraph_to_mermaid_for_simple_sim(simple_sim):\n    assert (\n        write_mermaid(to_digraph(simple_sim))\n        == \"\"\"graph LR\nHadesInternalProcess-7970269937446031133269215595648805179(HadesInternalProcess - 7970269937446031133269215595648805179) -- SimulationEnded --&gt; YearStartScheduler-332231294394531790607923355838092946842(YearStartScheduler - 332231294394531790607923355838092946842)\nHadesInternalProcess-7970269937446031133269215595648805179(HadesInternalProcess - 7970269937446031133269215595648805179) -- SimulationStarted --&gt; YearStartScheduler-332231294394531790607923355838092946842(YearStartScheduler - 332231294394531790607923355838092946842)\nYearStartScheduler-332231294394531790607923355838092946842(YearStartScheduler - 332231294394531790607923355838092946842) -- YearStarted --&gt; QuarterStartScheduler-7836064115094481643618470001379502846(QuarterStartScheduler - 7836064115094481643618470001379502846)\"\"\"\n    )\n</code></pre>"},{"location":"guides/visualisation/#visualising-using-the-state-of-a-process","title":"Visualising using the state of a process","text":"<p>Processes can be inspected after (or during a simulation) and used for visualisation. Boids Example</p> <p>An example of visualisation using process state can be seen in the boids example history collector process.</p>"},{"location":"guides/visualisation/#visualising-live-interactions","title":"Visualising live interactions","text":"<p>Processes can also be set up to asynchronously share events to clients for custom frontends. See the <code>WebSocketProcess</code>.</p> <p>Alternatively, <code>Hades</code> can be sub-classed to act as a server. This way all events and their results can be output to clients as they happen. See <code>HadesWS</code></p> <p>This style of visualisation is demonstrated in the boids example too</p>"}]}